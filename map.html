<!DOCTYPE html>
<html>
<head>
	<title>Hexagon</title>
	<meta charset="UTF-8" />
	<style type="text/css">
	body {
		position: absolute;
		left: 0;
		top: 0;
		right: 0;
		bottom: 0;
		margin: 0;
	}
	canvas {
		position: absolute;
		left: 0;
		top: 0;
		width: 100%;
		height: 100%;
	}
	</style>
</head>
<body>
	<canvas id="c"></canvas>
	<span id="info">0</span>
	<script type="text/javascript">
	(function(window,document) {
		var prefix = "", _addEventListener, support;
		if ( window.addEventListener ) _addEventListener = "addEventListener"; // detect event model
		else {
			_addEventListener = "attachEvent";
			prefix = "on";
		}
		// detect available wheel event
		support = "onwheel" in document.createElement("div") ? "wheel" : // Modern browsers support "wheel"
			document.onmousewheel !== undefined ? "mousewheel" : // Webkit and IE support at least "mousewheel"
			"DOMMouseScroll"; // let's assume that remaining browsers are older Firefox
		window.addWheelListener = function( elem, callback, useCapture ) {
			_addWheelListener( elem, support, callback, useCapture );
			// handle MozMousePixelScroll in older Firefox
			if( support == "DOMMouseScroll" ) _addWheelListener( elem, "MozMousePixelScroll", callback, useCapture );
		};
		function _addWheelListener( elem, eventName, callback, useCapture ) {
			elem[ _addEventListener ]( prefix + eventName, support == "wheel" ? callback : function( originalEvent ) {
				!originalEvent && ( originalEvent = window.event );
				var event = { // create a normalized event object
					originalEvent: originalEvent, // keep a ref to the original event object
					target: originalEvent.target || originalEvent.srcElement,
					type: "wheel",
					deltaMode: originalEvent.type == "MozMousePixelScroll" ? 0 : 1,
					deltaX: 0,  deltaY: 0,  deltaZ: 0,
					preventDefault: function() {
						originalEvent.preventDefault ?
							originalEvent.preventDefault() :
							originalEvent.returnValue = false;
					}
				};
				if ( support == "mousewheel" ) { // calculate deltaY (and deltaX) according to the event
					event.deltaY = - 1/40 * originalEvent.wheelDelta;
					originalEvent.wheelDeltaX && ( event.deltaX = -1/40 * originalEvent.wheelDeltaX ); // Webkit also support wheelDeltaX
				} else event.deltaY = originalEvent.detail;
				return callback( event ); // it's time to fire the callback
			}, useCapture || false );
		}
	})(window,document);
	var width = window.innerWidth, height = window.innerHeight,
	dragStart, dragged, keyspressed=new Array(100).fill(0), scaleFactor = 1.04;
	c.width = width; c.height = height;
	var t = c.getContext('2d'), m = 16, // context, map size, hexradius
	colors = ["#003fcf","#00ff3f","#cfcf00","#7f7f7f"], map = {};
	t.strokeStyle = "#000";
	t.lineWidth = 1;

	class Hex {
		constructor(x, y, z){
			this.type = type;
			this.color = colors[type];
			this.x = x;
			this.y = y;
			this.z = z || -x - y;
			this.owner = null;
			this.buildings = [];
			this.units = [];
			this.isCapital = false;
		}
		get neighbors(){
			
		}
	}
	function LFSR(seed){
		var state = seed & 65535, lsb = state & 1, period = -1, polynomial = 34425;
		function r(){
			++period;
			state >>>= 1;
			state ^= -lsb & polynomial;
			return lsb = state & 1;
		}
		r.byte = function(){ r(); return state & 255; }
		r();
		return r;
	}
	var r = LFSR(1);

	</script>
</body>