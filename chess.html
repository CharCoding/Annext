<!DOCTYPE html>
<html>
<head>
	<title>Battlefield</title>
	<meta charset="UTF-8" />
	<style type="text/css">
	#chessboard { position: absolute; left: 2vh; top: 2vh; width: 96vh; height: 96vh; }
	.row { position: relative; width: 96vh; height: 12vh; }
	.square { position: relative; display: inline-block; width: 12vh; height: 12vh; box-sizing: border-box; border: 0.5vh solid transparent; transition: border-color 200ms; }
	.square:focus { outline: none; border-color: #07f; }
	.row:nth-child(even)>.square:nth-child(even), .row:nth-child(odd)>.square:nth-child(odd) { background-color: #EEE; }
	.row:nth-child(odd)>.square:nth-child(even), .row:nth-child(even)>.square:nth-child(odd) { background-color: #111; }
	.valid::after{ content: ""; position: absolute; left: 50%; top: 50%; width: 2vh; height: 2vh; border-radius: 1vh;
		background-color: rgba(0, 216, 54, 0.66); margin: -1vh; }
	.white, .black { position: absolute; width: 10vh; height: 10vh; padding: 2vh 0; border-radius: 5vh; left: 50%;
		top: 50%; margin: -5vh; font-size: 4vh; text-align: center; box-sizing: border-box; border: .5vh solid #7F7F7F; }
	.black { background-color: #111; color: #EEE; } .white { background-color: #EEE; color: #111; }
	.white::before, .black::before {
		content: ""; display: inline-block; left: 50%; top: 50%; width: 12vh; height: 12vh; margin: -6vh;
		background-color: transparent; position: absolute; z-index: 4;
	}
	.inf::after { content: "INF";	} .min::after { content: "MIN";	} .tnk::after { content: "TNK";	}
	.art::after { content: "ART";	} .cru::after { content: "CRU";	} .des::after { content: "DES";	}
	.bts::after { content: "BTS";	} .acc::after { content: "ACC";	} .sub::after { content: "SUB";	}
	.ftr::after { content: "FTR";	} .bmb::after { content: "BMB";	} .hel::after { content: "HEL";	}
	.tra::after { content: "TRA";	}
	#info { position: absolute; right: 0; }
	#controls { position: absolute; left: 100vh; top: 25vh; bottom: 25vh; width: 25vh; }
	#controls>input { width: 25vh; box-sizing: border-box; text-align: center; }
	</style>
</head>
<body>
	<div id="chessboard"></div>
	<div id="controls">
		<input type="button" value="Propose ceasefire" id="ceasefire" /><br />
		<input type="button" value="Retreat" id="retreat" /><br />
		<input type="button" value="Surrender" id="surrender" />
	</div>
	<div id="info"></div>
	<script type="text/javascript">
	"use strict";
	const board = [], letters = "abcdefgh",
	// get square div element by x, y
	getSquare = (x, y) => document.getElementById(letters[x] + (8 - y)),
	// get x, y by square div element
	getXY = squ => [squ.id.charCodeAt(0) - 97, 8 - squ.id.slice(1)],
	// get content: 0 = empty, 1 = same color, -1 = opposite color. Color param is optional.
	// hack: +!! convers undefined to 0 and any object to 1
	getBoardContent = (x, y, color) => +!!board[x][y] && (board[x][y].color == color) * 2 - 1,
	showValidMoves = arr => {
		for(let i = 0, l = arr.length; i < l; i++){
			getSquare.apply(null, arr[i]).classList.add('valid');
		}
	},
	clearValidMoves = () => {
		for(let v = document.getElementsByClassName('valid'); v.length;)
			v[0].classList.remove('valid'); // hack: do not increment 0 because v updates dynamically
		pieceSelected = null;
	},
	assertEqual = (a, b) => a >= b && b >= a,
	movePiece = (x, y, x1, y1) => { // sync to html board
	  let squ = getSquare(x, y), squ1 = getSquare(x1, y1);
	  // Must assume move is correct; cannot doublecheck by getBoardContent because it already changed.
	  // don't specify x1 to simply kill the piece
	  if(x1 == undefined) return squ.removeChild(squ.children[0]);
	  if(squ1.children.length) squ1.removeChild(squ1.children[0]);
	  squ1.appendChild(squ.removeChild(squ.children[0]));
	  clearValidMoves(); // This is where it really should be
	}, searchCross = (x, y, color, range) => {
		let arr = [];
		for(let i = x - 1, m = Math.max(0, x - range); i >= m; i--){
	  	let content = getBoardContent(i, y, color);
	  	if(content == 1) break;
	    arr.push([i, y]);
	    if(content == -1) break;
	  }
	  for(let i = x + 1, m = Math.min(7, x + range); i <= m; i++){
	  	let content = getBoardContent(i, y, color);
	    if(content == 1) break;
	    arr.push([i, y]);
	    if(content == -1) break;
	  }
	  for(let j = y - 1, n = Math.max(0, y - range); j >= n; j--){
	  	let content = getBoardContent(x, j, color);
	    if(content == 1) break;
	    arr.push([x, j]);
	    if(content == -1) break;
	  }
	  for(let j = y + 1, n = Math.min(7, y + range); j <= n; j++){
	  	let content = getBoardContent(x, j, color);
	    if(content == 1) break;
	    arr.push([x, j]);
	    if(content == -1) break;
	  }
	  return arr;
	}, searchDiagonal = (x, y, color, range) => {
		let arr = [];
		for(let r = 1, m = Math.min(x, y, range); r <= m; r++){
	  	let content = getBoardContent(x - r, y - r, color);
	    if(content == 1) break;
	    arr.push([x - r, y - r]);
	    if(content == -1) break;
	  }
	  for(let r = 1, m = Math.min(7 - x, y, range); r <= m; r++){
	  	let content = getBoardContent(x + r, y - r, color);
	    if(content == 1) break;
	    arr.push([x + r, y - r]);
	    if(content == -1) break;
	  }
	  for(let r = 1, m = Math.min(7 - x, 7 - y, range); r <= m; r++){
	  	let content = getBoardContent(x + r, y + r, color);
	    if(content == 1) break;
	    arr.push([x + r, y + r]);
	    if(content == -1) break;
	  }
	  for(let r = 1, m = Math.min(x, 7 - y, range); r <= m; r++){
	  	let content = getBoardContent(x - r, y + r, color);
	    if(content == 1) break;
	    arr.push([x - r, y + r]);
	    if(content == -1) break;
	  }
	  return arr;
	}, searchKnight = (x, y, color) => {
		let arr = [];
		for(let i = -2; i < 3; i += 4){
	  	let x1 = x + i, y1 = y + i;
	    if(x1 >= 0 && x1 < 8 && y > 0 && getBoardContent(x1, y - 1, color) < 1) arr.push([x1, y - 1]);
	    if(x1 >= 0 && x1 < 8 && y < 7 && getBoardContent(x1, y + 1, color) < 1) arr.push([x1, y + 1]);
	    if(y1 >= 0 && y1 < 8 && x > 0 && getBoardContent(x - 1, y1, color) < 1) arr.push([x - 1, y1]);
	    if(y1 >= 0 && y1 < 8 && x < 7 && getBoardContent(x + 1, y1, color) < 1) arr.push([x + 1, y1]);
	  }
	  return arr;
	};
	let pieceSelected = null;
	for(let i = 0; i < 8; i++) {
		let row = document.createElement('div');
		row.className = "row";
		for(let j = 0; j < 8; j++) {
			let squ = document.createElement('div');
			squ.className = "square";
			squ.id = letters[j] + (8 - i);
			squ.tabIndex = i * 8 + j + 1;
	    squ.addEventListener('click',function(e){
	    	let arr = getXY(this);
	    	info.innerText = arr + ' ' + this.id;
	    	if(pieceSelected && this.classList.contains('valid')){
	    		pieceSelected.move(arr[0], arr[1]);
	    		pieceSelected = null;
	    	}else if(getBoardContent(arr[0], arr[1], Game.turn) == 1){
	    		clearValidMoves();
	    		pieceSelected = board[arr[0]][arr[1]];
	    		showValidMoves(
	    			pieceSelected.getMoves().filter(arr => getBoardContent.apply(null, arr) == 0).concat(
	    				pieceSelected.getSupports().filter(arr => getBoardContent.apply(null, arr) == -1)
	    			)
	    		);
	    	}
	    }, true);
			row.appendChild(squ);
		}
		board[i] = new Array(8);
		chessboard.appendChild(row);
	}
	class Piece {
	  constructor(x, y, type, color) {
	  	let square = getSquare(x, y);
	    if(square.children.length) throw new Error('Square is already occupied');
	    this.x = x;
	    this.y = y;
	    this.color = color;
	    this.attackPower = 1;
	    /* // experimental: do not connect piece object to html elements.
	    // movements should be made on the 2D array and synced to the html board.
	    this.elm = document.createElement('div');
	    this.elm.className = type + ' ' + color;
	    // */
	    let elm = document.createElement('div');
	    elm.className = type + ' ' + color;
	    square.appendChild(elm);
	    return board[x][y] = this;
	  }
	  move(x, y) {
	  	if(x < 0 || x > 7 || y < 0 || y > 7) throw new Error('Invalid square');
	  	let content = getBoardContent(x, y, this.color)
	  	if(content == 1) throw new Error('Invalid move');
	  	if(content == 0){
	  		board[x][y] = this;
	  		delete board[this.x][this.y];
	  		movePiece(this.x, this.y, x, y);
	  		this.x = x;
	  		this.y = y;
	  	} else {
	  		let supports = Game[this.color], attackPower = 0;
	  		for(let i = 0, l = supports.length; i < l; i++)
	  			attackPower += supports[i].support(x, y);
	  		if(attackPower + 0.5 >= board[x][y].attackPower){
	  			board[x][y].die();
	  			board[x][y] = this;
	  			delete board[this.x][this.y];
	  			movePiece(this.x, this.y, x, y);
	  			this.x = x;
	  			this.y = y;
	  		} else {
	  			this.die();
	  			delete board[this.x][this.y];
	  			movePiece(this.x, this.y);
	  		}
	  	}
	  	Game.turn = Game.turn == 'white' ? 'black' : 'white';
	  }
	  die() {
	  	delete this;
	  }
	  support(x, y){
	  	let moves = this.getSupports(), squ = [x, y];
	  	while(moves.length){
	  		if(assertEqual(moves.pop(), squ)) return this.attackPower;
	  	}
	  	return 0;
	  }
	  getSupports() { return []; }
	  getMoves() { return []; }
	}
	class Infantry extends Piece {
	  constructor(x, y, color) {
			super(x, y, 'inf', color);
			this.attackPower = 0.5;
		}
		getSupports() {
			return searchDiagonal(this.x, this.y, this.color, 1);
		}
	  getMoves() {
	  	return searchCross(this.x, this.y, this.color, 1);
	  	// blitz = searchCross(this.x, this.y, this.color, 7).filter()
	  }
	}
	class MechanizedInfantry extends Piece {
	  constructor(x, y, color) {
			super(x, y, 'min', color);
		}
		getSupports() {
			return searchDiagonal(this.x, this.y, this.color, 7);
		}
		getMoves() {
			return searchDiagonal(this.x, this.y, this.color, 7).concat(searchCross(this.x, this.y, this.color, 1));
		}
	}
	class Tank extends Piece {
	  constructor(x, y, color) {
			super(x, y, 'tnk', color);
			this.attackPower = 1.5;
		}
		getSupports() {
			return searchCross(this.x, this.y, this.color, 7);
		}
		getMoves() {
			return searchCross(this.x, this.y, this.color, 7);
		}
	}
	class Artillery extends Piece {
	  constructor(x, y, color) {
			super(x, y, 'art', color);
		}
		getSupports() {
			return searchKnight(this.x, this.y, this.color);
		}
		getMoves() {
			return searchKnight(this.x, this.y, this.color).concat([[this.x, this.y]]); // add "bombard option"
		}
	}
	class Cruiser extends Piece {
	  constructor(x, y, color) {
			super(x, y, 'cru', color);
		}
		getSupports() {
			return searchCross(this.x, this.y, this.color, 7);
		}
		getMoves() {
			return searchCross(this.x, this.y, this.color, 7);
		}
	}
	class Destroyer extends Piece {
		constructor(x, y, color) {
			super(x, y, 'des', color);
		}
		getSupports() {
			return searchDiagonal(this.x, this.y, this.color, 7);
		}
		getMoves() {
			return searchDiagonal(this.x, this.y, this.color, 7).concat(searchCross(this.x, this.y, this.color, 1));
		}
	}
	class Battleship extends Piece {
		constructor(x, y, color) {
			super(x, y, 'bts', color);
			this.attackPower = 2.5;
		}
		getSupports() {
			return searchKnight(this.x, this.y, this.color);
		}
		getMoves() {
			return searchKnight(this.x, this.y, this.color);
		}
	}
	class AircraftCarrier extends Piece {
		constructor(x, y, color) {
			super(x, y, 'acc', color);
			this.attackPower = 2.5;
		}
		getSupports(){
			return searchCross(this.x, this.y, this.color, 7).concat(searchDiagonal(this.x, this.y, this.color, 7));
		}
		getMoves(){
			return searchCross(this.x, this.y, this.color, 7).concat(searchDiagonal(this.x, this.y, this.color, 7));	
		}
	}
	class Submarine extends Piece { // need to add in-range instakill
		constructor(x, y, color) {
			super(x, y, 'sub', color);
		}
		getSupports() {
			return searchCross(this.x, this.y, this.color, 2);
		}
		getMoves() {
			return searchCross(this.x, this.y, this.color, 2);
		}
	}
	class Fighter extends Piece { //REMEMBER: can move past unit after killing
		constructor(x, y, color) {
			super(x, y, 'ftr', color);
		}
		getSupports(){
			return searchCross(this.x, this.y, this.color, 7).concat(searchDiagonal(this.x, this.y, this.color, 7));
		}
		getMoves(){
			return searchCross(this.x, this.y, this.color, 7).concat(searchDiagonal(this.x, this.y, this.color, 7));	
		}
	}
	class Bomber extends Piece {
		constructor(x, y, color) {
			super(x, y, 'bmb', color);
			this.attackPower = 1.5;
		}
		getSupports(){
			return searchCross(this.x, this.y, this.color, 1);
		}
		getMoves(){
			return searchCross(this.x, this.y, this.color, 1);
		}
		/* // Piece.move() should link to a search of all bombers on board and kill corresponding pieces.
		get instakills() { //when running turn, maybe check if piece has .instakills prop and if so call it? yes.
			return getValidMoves(this.x, this.y, 1, 1).filter(arr => isOpposite.apply(null, arr.concat([this.color]))); //that way not every piece needs an instakills getter
		}
		*/
	}
	class Transport extends Piece {
		constructor(x, y, color) {
			super(x, y, 'tra', color);
		}
		getSupports(){
			return []; // can't attack, no support
		}
		getMoves(){
			return searchCross(this.x, this.y, this.color, 7);
		}
	}
	class Helicopter extends Piece {
		constructor(x, y, color) {
			super(x, y, 'hel', color);
		}
		getSupports(){
			return searchKnight(this.x, this.y, this.color);
		}
		getMoves(){
			return searchDiagonal(this.x, this.y, this.color, 1).concat(searchCross(this.x, this.y, this.color, 1));
		}
	}
	const Game = {
		black: [
			new Tank(1, 1, "black"),
			new MechanizedInfantry(2, 1, "black"),
			new Artillery(3, 1, "black"),
			new Helicopter(4, 1, "black"),
			new MechanizedInfantry(5, 1, "black"),
			new Tank(6, 1, "black"),
			new Infantry(2, 2, "black"),
			new Infantry(3, 2, "black"),
			new Infantry(4, 2, "black"),
			new Infantry(5, 2, "black"),
			new Infantry(0, 3, "black"),
			new Infantry(7, 3, "black"),
		], white: [
			new Infantry(0, 4, "white"),
			new Infantry(7, 4, "white"),
			new Infantry(2, 5, "white"),
			new Infantry(3, 5, "white"),
			new Infantry(4, 5, "white"),
			new Infantry(5, 5, "white"),
			new Tank(1, 6, "white"),
			new MechanizedInfantry(2, 6, "white"),
			new Artillery(3, 6, "white"),
			new Helicopter(4, 6, "white"),
			new MechanizedInfantry(5, 6, "white"),
			new Tank(6, 6, "white"),
		], turn: "white"
	};
	</script>
</body>
