<!DOCTYPE html>
<html>
<head>
	<title>Battlefield</title>
	<meta charset="UTF-8" />
	<style type="text/css">
	#chessboard { position: absolute; left: 2vh; top: 2vh; width: 96vh; height: 96vh; }
	.row { position: relative; width: 96vh; height: 12vh; }
	.square { position: relative; display: inline-block; width: 12vh; height: 12vh; box-sizing: border-box; border: 0.5vh solid transparent; transition: border-color 200ms; }
	.square:focus { outline: none; border-color: #07f; }
	.row:nth-child(even)>.square:nth-child(even), .row:nth-child(odd)>.square:nth-child(odd) { background-color: #EEE; }
	.row:nth-child(odd)>.square:nth-child(even), .row:nth-child(even)>.square:nth-child(odd) { background-color: #111; }
	.valid::after, .invalid::after { content: ""; position: absolute; left: 50%; top: 50%; width: 2vh; height: 2vh; border-radius: 1vh; margin: -1vh;	}
	.valid::after{ background-color: rgba(0, 216, 54, 0.66) !important; }
	.invalid::after{ background-color: rgba(216, 54, 0, 0.66); }
	.white, .black { position: absolute; width: 10vh; height: 10vh; padding: 2vh 0; border-radius: 5vh; left: 50%;
		top: 50%; margin: -5vh; font-size: 4vh; text-align: center; box-sizing: border-box; border: .5vh solid #7F7F7F; }
	.black { background-color: #111; color: #EEE; } .white { background-color: #EEE; color: #111; }
	.white::before, .black::before {
		content: ""; display: inline-block; left: 50%; top: 50%; width: 12vh; height: 12vh; margin: -6vh;
		background-color: transparent; position: absolute; z-index: 4;
	}
	.inf::after { content: "INF";	} .min::after { content: "MIN";	} .tnk::after { content: "TNK";	}
	.art::after { content: "ART";	} .cru::after { content: "CRU";	} .des::after { content: "DES";	}
	.bts::after { content: "BTS";	} .acc::after { content: "ACC";	} .sub::after { content: "SUB";	}
	.ftr::after { content: "FTR";	} .bmb::after { content: "BMB";	} .hel::after { content: "HEL";	}
	.tra::after { content: "TRA";	} /* WHERE R MY ICONS */
	#info { position: absolute; right: 0; }
	#controls { position: absolute; left: 100vh; top: 25vh; bottom: 25vh; width: 25vh; }
	#controls>input { width: 25vh; box-sizing: border-box; text-align: center; margin: .5vh 0; }
	</style>
</head>
<body>
	<div id="chessboard"></div>
	<div id="controls">
		<input type="button" value="Skip turn" id="skip" /><br />
		<input type="button" value="Propose ceasefire" id="ceasefire" /><br />
		<input type="button" value="Retreat" id="retreat" /><br />
		<input type="button" value="Surrender" id="surrender" />
	</div>
	<script type="text/javascript">
	// TODO: When program is finished wrap everything in anonymous function to keep global clean
	"use strict";
	// CONSTANTS, API FUNCTIONS, ETC.
	const board = new Array(8), letters = "abcdefgh",
	getSquare = (x, y) => document.getElementById(letters[x] + (8 - y)), // get square div element by x, y
	getXY = squ => [squ.id.charCodeAt(0) - 97, 8 - squ.id.slice(1)], // get x, y by square div element

	// getBoardContent: 0 = empty, 1 = same color, -1 = opposite color. Color param is optional.
	// hack: +!! convers undefined to 0 and any object to 1
	getBoardContent = (x, y, color) => +!!board[x][y] && (board[x][y].color == color) * 2 - 1,

	// getLineContent(x, y, x1, y1, color) returns an array indicating how many friendly/enemy pieces lie on
	// the line between (x, y) and (x1, y1).
	getLineContent = (x, y, x1, y1, color) => {
		// hack: (a > b) - (a < b) determines the direction of steps to make
		// 1 if end > start, -1 if end < start, 0 if the same
		let contents = [0, 0], dx = (x1 > x) - (x1 < x), dy = (y1 > y) - (y1 < y);
		x += dx;
		y += dy;
		for(;x != x1 || y != y1; x += dx, y += dy) {
			let content = getBoardContent(x, y, color);
			if(content == 1) contents[0]++;
			else if(content == -1) contents[1]++;
		}
		return contents;
	},
	showValidMoves = moves => {
		for(let i = 0, l = moves.length; i < l; i++)
			getSquare(...moves[i]).classList.add('valid'); // fn(...arr): spread operator
	},
	clearValidMoves = () => {
		for(let v = document.getElementsByClassName('valid'); v.length;)
			v[0].classList.remove('valid'); // hack: do not increment 0 because v updates dynamically
		pieceSelected = null;

		// debug: remove red dots as well
		// for(let i = document.getElementsByClassName('invalid'); i.length;)
		// i[0].classList.remove('invalid');
	},
	assertEqual = (a, b) => a >= b && b >= a, // hack: check two arrays are identical.
	movePiece = (x, y, x1, y1) => { // sync to html board
	  let squ = getSquare(x, y);
	  // Must assume move is correct; cannot doublecheck by getBoardContent because it already changed.
	  // Please don't cheat.
	  // leave x1 as undefined to simply kill the piece
	  if(x1 == undefined) return squ.removeChild(squ.children[0]);
	  let squ1 = getSquare(x1, y1);
	  if(squ1.children.length) squ1.removeChild(squ1.children[0]);
	  squ1.appendChild(squ.removeChild(squ.children[0]));
	  clearValidMoves(); // This is where it really should be
	},
	searchCross = (x, y, color, range) => { // Piece movement listing functions
		let arr = [];
		for(let i = x - 1, m = Math.max(0, x - range); i >= m; i--){
	  	let content = getBoardContent(i, y, color);
	  	if(content == 1) break;
	    arr.push([i, y]);
	    if(content == -1) break;
	  }
	  for(let i = x + 1, m = Math.min(7, x + range); i <= m; i++){
	  	let content = getBoardContent(i, y, color);
	    if(content == 1) break;
	    arr.push([i, y]);
	    if(content == -1) break;
	  }
	  for(let j = y - 1, n = Math.max(0, y - range); j >= n; j--){
	  	let content = getBoardContent(x, j, color);
	    if(content == 1) break;
	    arr.push([x, j]);
	    if(content == -1) break;
	  }
	  for(let j = y + 1, n = Math.min(7, y + range); j <= n; j++){
	  	let content = getBoardContent(x, j, color);
	    if(content == 1) break;
	    arr.push([x, j]);
	    if(content == -1) break;
	  }
	  return arr;
	}, searchDiagonal = (x, y, color, range) => {
		let arr = [];
		for(let r = 1, m = Math.min(x, y, range); r <= m; r++){
	  	let content = getBoardContent(x - r, y - r, color);
	    if(content == 1) break;
	    arr.push([x - r, y - r]);
	    if(content == -1) break;
	  }
	  for(let r = 1, m = Math.min(7 - x, y, range); r <= m; r++){
	  	let content = getBoardContent(x + r, y - r, color);
	    if(content == 1) break;
	    arr.push([x + r, y - r]);
	    if(content == -1) break;
	  }
	  for(let r = 1, m = Math.min(7 - x, 7 - y, range); r <= m; r++){
	  	let content = getBoardContent(x + r, y + r, color);
	    if(content == 1) break;
	    arr.push([x + r, y + r]);
	    if(content == -1) break;
	  }
	  for(let r = 1, m = Math.min(x, 7 - y, range); r <= m; r++){
	  	let content = getBoardContent(x - r, y + r, color);
	    if(content == 1) break;
	    arr.push([x - r, y + r]);
	    if(content == -1) break;
	  }
	  return arr;
	}, searchKnight = (x, y, color) => {
		let arr = [];
		for(let i = -2; i < 3; i += 4){
	  	let x1 = x + i, y1 = y + i;
	    if(x1 >= 0 && x1 < 8 && y > 0 && getBoardContent(x1, y - 1, color) < 1) arr.push([x1, y - 1]);
	    if(x1 >= 0 && x1 < 8 && y < 7 && getBoardContent(x1, y + 1, color) < 1) arr.push([x1, y + 1]);
	    if(y1 >= 0 && y1 < 8 && x > 0 && getBoardContent(x - 1, y1, color) < 1) arr.push([x - 1, y1]);
	    if(y1 >= 0 && y1 < 8 && x < 7 && getBoardContent(x + 1, y1, color) < 1) arr.push([x + 1, y1]);
	  }
	  return arr;
	}, Game = {
		black: [], white: [], turn: "white", retreating: false
	};

	// Initialize board, piece movement event listeners
	let pieceSelected = null;
	for(let i = 0; i < 8; i++) {
		let row = document.createElement('div');
		row.className = "row";
		for(let j = 0; j < 8; j++) {
			let squ = document.createElement('div');
			squ.className = "square";
			squ.id = letters[j] + (8 - i);
			squ.tabIndex = i * 8 + j + 1;
	    squ.addEventListener('click',function(e){
	    	let [x, y] = getXY(this);
	    	// arr.push(Game.turn); // add color to movement array so that spread operator can be used properly
	    	// info.innerText = x + ', ' + y + ' ' + this.id;
	    	if(pieceSelected && this.classList.contains('valid')){
	    		pieceSelected.move(x, y); // doesn't matter in here because .move() only takes 2 parameters
	    		pieceSelected = null;
	    	}else if(getBoardContent(x, y, Game.turn) == 1){ // it is used here (x, y, color)
	    		clearValidMoves();
	    		pieceSelected = board[x][y];
	    		showValidMoves(
	    			pieceSelected.getMoves().filter(arr => getBoardContent(...arr) == 0).concat(
	    				pieceSelected.getSupports().filter(arr => getBoardContent(...arr) == -1)
	    			)
	    		);
	    	}else clearValidMoves();
	    }, true);
			row.appendChild(squ);
		}
		board[i] = new Array(8);
		chessboard.appendChild(row);
	}

	// PIECES CONSTRUCTORS
	class Piece {
	  constructor(x, y, type, color) {
	  	let square = getSquare(x, y);
	    if(square.children.length) throw new Error('Square is already occupied');
	    this.x = x;
	    this.y = y;
	    this.color = color;
	    this.id = Game[color].push(this) - 1; // for ease of deleting object
	    this.attackPower = 1;
	    let elm = document.createElement('div');
	    elm.className = type + ' ' + color;
	    square.appendChild(elm);
	    return board[x][y] = this;
	  }
	  move(x, y) {
	  	if(x < 0 || x > 7 || y < 0 || y > 7) throw new Error('Invalid square');
	  	let content = getBoardContent(x, y, this.color);
	  	if(content == 1) throw new Error('Invalid move');
	  	if(content == 0){
	  		board[x][y] = this;
	  		delete board[this.x][this.y];
	  		movePiece(this.x, this.y, x, y);
	  		this.x = x;
	  		this.y = y;
	  	}else{
	  		let supports = Game[this.color], attackPower = this.attackPower;
	  		for(let i = 0, l = supports.length; i < l; i++)
	  			if(supports[i] && supports[i] != this) attackPower += supports[i].support(x, y);
	  		if(attackPower + 0.5 >= board[x][y].attackPower){
	  			board[x][y].die();
	  			board[x][y] = this;
	  			delete board[this.x][this.y];
	  			movePiece(this.x, this.y, x, y);
	  			this.x = x;
	  			this.y = y;
	  		}else{
	  			delete board[this.x][this.y];
	  			this.die();
	  			movePiece(this.x, this.y);
	  		}
	  	}
	  	Game.turn = Game.turn == 'white' ? 'black' : 'white';
	  }
	  die() { delete Game[this.color][this.id]; } // only way to delete a piece, leaving holes in the array.
	  support(x, y){
	  	// NOTE: getSupports() defaults to "include special move", in the case of Infantry, it includes
	  	// Blitz attacks. Make sure it doesn't by specifying excludeBlitz = true
	  	let moves = this.getSupports(true), squ = [x, y];
	  	while(moves.length) if(assertEqual(moves.pop(), squ)) return this.attackPower;
	  	return 0;
	  }
	}
	class Infantry extends Piece {
	  constructor(x, y, color) {
			super(x, y, 'inf', color);
			this.attackPower = 0.5;
		}
		getSupports(excludeBlitz) {
			let moves = searchDiagonal(this.x, this.y, this.color, 1);
			if(excludeBlitz) return moves;
			let infantries = Game[this.color].filter(e => e.constructor == Infantry && e != this);
			infantries.forEach(e => {
				let supports = e.getSupports(true), l = supports.length;
				for(let i = 0; i < l; i++){
					let [x, y] = supports[i];
					// getSquare(x, y).classList.add('invalid');
					if((x != this.x) != (y != this.y)){ // logical xor
						let [friend, enemy] = getLineContent(this.x, this.y, x, y, this.color);
						// hack: sum of getLineContent has to be 0, so use logical or to exclude sum > 0.
						friend + enemy || moves.push(supports[i]);
					}
				}
			});
			return moves;
		}
	  getMoves() {
	  	return searchCross(this.x, this.y, this.color, 1);
	  }
	}
	class MechanizedInfantry extends Piece {
	  constructor(x, y, color) {
			super(x, y, 'min', color);
		}
		getSupports() {
			return searchDiagonal(this.x, this.y, this.color, 7);
		}
		getMoves() {
			return searchDiagonal(this.x, this.y, this.color, 7).concat(searchCross(this.x, this.y, this.color, 1));
		}
	}
	class Tank extends Piece {
	  constructor(x, y, color) {
			super(x, y, 'tnk', color);
			this.attackPower = 1.5;
		}
		getSupports(excludeBlitz) {
			let moves = searchCross(this.x, this.y, this.color, 7);
			if(excludeBlitz) return moves;
			let infantries = Game[this.color].filter(e => e.constructor == Infantry);
			infantries.forEach(e => {
				let supports = e.getSupports(true), l = supports.length;
				for(let i = 0; i < l; i++){
					let [x, y] = supports[i];
					if((x != this.x) != (y != this.y)){
						let friend = getLineContent(this.x, this.y, x, y, this.color)[0];
						friend || moves.push(supports[i]);
					}
				}
			});
			return moves;
		}
		getMoves() {
			return searchCross(this.x, this.y, this.color, 7);
		}
		move(x, y) {
			let tx = this.x, ty = this.y, dx = (x > tx) - (x < tx), dy = (y > ty) - (y < ty),
			infantries = searchDiagonal(x, y, this.color == 'white' ? 'black' : 'white', 1);
			// eliminate pieces of opposite color
			// console.log(infantries);
			super.move(x, y);
			for(let i = 0, l = infantries.length; i < l; i++) {
				let [x, y] = infantries[i], piece = board[x][y];
				if(piece && piece.color == this.color && piece.constructor == Infantry) {
					if(dx == 0) {
						for(ty += dy; ty != this.y; ty += dy) {
							if(getBoardContent(this.x, ty, this.color) == -1) {
								movePiece(this.x, ty);
								board[this.x][ty].die();
								delete board[this.x][ty];
							}
						}
					} else if(dy == 0) {
						for(tx += dx; tx != this.x; tx += dx) {
							if(getBoardContent(tx, this.y, this.color) == -1) {
								movePiece(tx, this.y);
								board[tx][this.y].die();
								delete board[tx][this.y];
							}
						}
					}
				}
			}
		}
	}
	class Artillery extends Piece {
	  constructor(x, y, color) {
			super(x, y, 'art', color);
		}
		getSupports() {
			return searchKnight(this.x, this.y, this.color);
		}
		getMoves() {
			return searchKnight(this.x, this.y, this.color);
		}
		move(x, y) {
			// Too lazy to make custom prompt box; using default confirm() instead.
			// Pro: script automatically pauses to wait for user input, no extra callbacks required
			// Con: player can click "Prevent showing dialogs" (please don't do that)
			if(getBoardContent(x, y, this.color) == -1) var bombard = confirm("Bombard? Cancel for regular movement.");
			if(bombard){
				movePiece(x, y);
				board[x][y].die();
				delete board[x][y];
				Game.turn = Game.turn == 'white' ? 'black' : 'white';
			}else super.move(x, y);
		}
	}
	class Cruiser extends Piece {
	  constructor(x, y, color) {
			super(x, y, 'cru', color);
		}
		getSupports() {
			return searchCross(this.x, this.y, this.color, 7);
		}
		getMoves() {
			return searchCross(this.x, this.y, this.color, 7);
		}
	}
	class Destroyer extends Piece {
		constructor(x, y, color) {
			super(x, y, 'des', color);
		}
		getSupports() {
			return searchDiagonal(this.x, this.y, this.color, 7);
		}
		getMoves() {
			return searchDiagonal(this.x, this.y, this.color, 7).concat(searchCross(this.x, this.y, this.color, 1));
		}
	}
	class Battleship extends Piece {
		constructor(x, y, color) {
			super(x, y, 'bts', color);
			this.attackPower = 2.5;
		}
		getSupports() {
			return searchKnight(this.x, this.y, this.color);
		}
		getMoves() {
			return searchKnight(this.x, this.y, this.color);
		}
	}
	class AircraftCarrier extends Piece {
		constructor(x, y, color) {
			super(x, y, 'acc', color);
			this.attackPower = 2.5;
		}
		getSupports(){
			return searchCross(this.x, this.y, this.color, 7).concat(searchDiagonal(this.x, this.y, this.color, 7));
		}
		getMoves(){
			return searchCross(this.x, this.y, this.color, 7).concat(searchDiagonal(this.x, this.y, this.color, 7));	
		}
	}
	class Submarine extends Piece { // need to add in-range instakill
		constructor(x, y, color) {
			super(x, y, 'sub', color);
		}
		getSupports() {
			return searchCross(this.x, this.y, this.color, 2);
		}
		getMoves() {
			return searchCross(this.x, this.y, this.color, 2);
		}
	}
	class Fighter extends Piece { //REMEMBER: can move past unit after killing
		constructor(x, y, color) {
			super(x, y, 'ftr', color);
		}
		getSupports(){
			return searchCross(this.x, this.y, this.color, 7).concat(searchDiagonal(this.x, this.y, this.color, 7));
			// let moves = [];
		}
		getMoves(){
			return searchCross(this.x, this.y, this.color, 7).concat(searchDiagonal(this.x, this.y, this.color, 7));	
		}
	}
	class Bomber extends Piece {
		constructor(x, y, color) {
			super(x, y, 'bmb', color);
			this.attackPower = 1.5;
		}
		getSupports(){
			// return searchCross(this.x, this.y, this.color, 1);
			return []; // bomber's surrounding is always empty.
		}
		getMoves(){
			return searchCross(this.x, this.y, this.color, 1);
		}
		/* // Piece.move() should link to a search of all bombers on board and kill corresponding pieces.
		get instakills() { //when running turn, maybe check if piece has .instakills prop and if so call it? yes.
			return getValidMoves(this.x, this.y, 1, 1).filter(arr => isOpposite.apply(null, arr.concat([this.color]))); //that way not every piece needs an instakills getter
		}
		*/
	}
	class Transport extends Piece {
		constructor(x, y, color) {
			super(x, y, 'tra', color);
		}
		getSupports(){
			return []; // can't attack, no support
		}
		getMoves(){
			return searchCross(this.x, this.y, this.color, 7);
		}
	}
	class Helicopter extends Piece {
		constructor(x, y, color) {
			super(x, y, 'hel', color);
		}
		getSupports(){
			return searchKnight(this.x, this.y, this.color);
		}
		getMoves(){
			return searchDiagonal(this.x, this.y, this.color, 1).concat(searchCross(this.x, this.y, this.color, 1));
		}
	}

	// EVENT LISTENERS
	skip.addEventListener('click',function(e){
		Game.turn = Game.turn == 'white' ? 'black' : 'white';
	});
	ceasefire.addEventListener('click',function(e){

	});
	retreat.addEventListener('click',function(e){
		Game.retreating = true; // Uhhh
	});
	surrender.addEventListener('click',function(e){
		for(let i = 0; i < 8; i++){
			for(let j = 0; j < 8; j++){
				if(board[i][j] && board[i][j].color == Game.turn){
					board[i][j].color = Game.turn == 'white' ? 'black' : 'white';
					getSquare(i, j).children[0].classList.toggle('white');
					getSquare(i, j).children[0].classList.toggle('black');
				}
			}
		}
	});
	//*
	new Tank(1, 0, "black");
	new Tank(6, 0, "black");
	new Transport(1, 1, "black");
	new MechanizedInfantry(2, 1, "black");
	new Artillery(3, 1, "black");
	new Helicopter(4, 1, "black");
	new MechanizedInfantry(5, 1, "black");
	new Transport(6, 1, "black");
	new Infantry(2, 2, "black");
	new Infantry(3, 2, "black");
	new Infantry(4, 2, "black");
	new Infantry(5, 2, "black");
	new Infantry(0, 3, "black");
	new Infantry(7, 3, "black");

	new Infantry(0, 4, "white");
	new Infantry(7, 4, "white");
	new Infantry(2, 5, "white");
	new Infantry(3, 5, "white");
	new Infantry(4, 5, "white");
	new Infantry(5, 5, "white");
	new Transport(1, 6, "white");
	new MechanizedInfantry(2, 6, "white");
	new Artillery(3, 6, "white");
	new Helicopter(4, 6, "white");
	new MechanizedInfantry(5, 6, "white");
	new Transport(6, 6, "white");
	new Tank(1, 7, "white");
	new Tank(6, 7, "white");
	//*/
	/*
	new Infantry(0, 1, "white");
	new Infantry(1, 7, "white");
	new Infantry(2, 2, "white");
	new Infantry(0, 6, "white");
	new Infantry(2, 6, "black");
	new Tank(1, 0, "black");
	new Tank(1, 3, "black");
	new Tank(1, 5, "white");
	new Artillery(3, 4, "white");
	//*/
	</script>
</body>
</html>
