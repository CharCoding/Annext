<!DOCTYPE html>
<html>
<head>
	<title>Hexagon</title>
	<meta charset="UTF-8" />
	<style type="text/css">
	body {
		position: absolute;
		left: 0;
		top: 0;
		right: 0;
		bottom: 0;
		margin: 0;
	}
	canvas {
		position: absolute;
		left: 0;
		top: 0;
		width: 100%;
		height: 100%;
	}
	</style>
</head>
<body>
	<canvas id="c"></canvas>
	<span id="info">0</span>
	<script type="text/javascript">
	(function(window,document) {
		var prefix = "", _addEventListener, support;
		if ( window.addEventListener ) _addEventListener = "addEventListener"; // detect event model
		else {
			_addEventListener = "attachEvent";
			prefix = "on";
		}
		// detect available wheel event
		support = "onwheel" in document.createElement("div") ? "wheel" : // Modern browsers support "wheel"
			document.onmousewheel !== undefined ? "mousewheel" : // Webkit and IE support at least "mousewheel"
			"DOMMouseScroll"; // let's assume that remaining browsers are older Firefox
		window.addWheelListener = function( elem, callback, useCapture ) {
			_addWheelListener( elem, support, callback, useCapture );
			// handle MozMousePixelScroll in older Firefox
			if( support == "DOMMouseScroll" ) _addWheelListener( elem, "MozMousePixelScroll", callback, useCapture );
		};
		function _addWheelListener( elem, eventName, callback, useCapture ) {
			elem[ _addEventListener ]( prefix + eventName, support == "wheel" ? callback : function( originalEvent ) {
				!originalEvent && ( originalEvent = window.event );
				var event = { // create a normalized event object
					originalEvent: originalEvent, // keep a ref to the original event object
					target: originalEvent.target || originalEvent.srcElement,
					type: "wheel",
					deltaMode: originalEvent.type == "MozMousePixelScroll" ? 0 : 1,
					deltaX: 0,  deltaY: 0,  deltaZ: 0,
					preventDefault: function() {
						originalEvent.preventDefault ?
							originalEvent.preventDefault() :
							originalEvent.returnValue = false;
					}
				};
				if ( support == "mousewheel" ) { // calculate deltaY (and deltaX) according to the event
					event.deltaY = - 1/40 * originalEvent.wheelDelta;
					originalEvent.wheelDeltaX && ( event.deltaX = -1/40 * originalEvent.wheelDeltaX ); // Webkit also support wheelDeltaX
				} else event.deltaY = originalEvent.detail;
				return callback( event ); // it's time to fire the callback
			}, useCapture || false );
		}
	})(window,document);
	var width = window.innerWidth, height = window.innerHeight, lastX=c.width/2, lastY=c.height/2,
	dragStart, dragged, keyspressed=new Array(100).fill(0), scaleFactor = 1.04;
	c.width = width; c.height = height;
	var t = c.getContext('2d'), m = 16, hr = 5.773502691896258, // context, map size, hexradius
	colors = ["#003fcf","#00ff3f","#cfcf00","#7f7f7f"];
	trackTransforms(t);
	t.strokeStyle = "#000";
	t.lineWidth = 0.5;
	function drawHex(x, y) {
		t.beginPath();
		t.moveTo(x + hr, y);
		for(var i=1;i<6;i++){
			t.lineTo(x + Math.cos(Math.PI * i / 3) * hr, y + Math.sin(Math.PI * i / 3) * hr);
		}
  	t.closePath();
  	t.stroke();
	}
	function LFSR(seed){
		var state = seed & 65535, lsb = state & 1, period = -1, polynomial = 34425;
		function r(){
			++period;
			state >>>= 1;
			state ^= -lsb & polynomial;
			return lsb = state & 1;
		}
		r.byte = function(){ r(); return state & 255; }
		r();
		return r;
	}
	var r = LFSR(1);
	function redraw(){
		t.save();
		t.setTransform(1,0,0,1,0,0);
		t.clearRect(0,0,c.width,c.height);
		t.restore();
		for(var i = 0; i < m * 2 + 1; i++){
			for(var j = 0, k = m * 2 + 1 - Math.abs(i - m); j < k; j++){
 				var l = j + (i - m) * (i > m), point = t.transformedPoint(lastX, lastY);
				drawHex(l * Math.cos(-Math.PI / 6) * 10, (i + l * Math.sin(-Math.PI / 6)) * 10);
				if(Math.hypot(l * Math.cos(-Math.PI / 6) * 10 - point.x, (i + l * Math.sin(-Math.PI / 6)) * 10 - point.y) < hr){
 					t.fillStyle = "#f00";
 					t.fill();
 				}
			}
		}
		t.fillStyle = "#0000ff";
		t.save();
		t.setTransform(1,0,0,1,0,0);
		t.fillRect(lastX - 2, lastY - 2, 4, 4);
		t.restore();
		var movement = t.transformedPoint(0,0).x - t.transformedPoint(4,0).x;
		t.translate(-movement * keyspressed[65],0);
		t.translate(0,-movement * keyspressed[87]);
		t.translate(movement * keyspressed[68],0);
		t.translate(0,movement * keyspressed[83]);
		var matrix = t.getTransform();
		info.innerHTML = [matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f].map(function(n){return n.toFixed(3);}).join(' ') + ' ' + lastX.toFixed(3) + ' ' +  lastY.toFixed(3);
		r = LFSR(1);
  	timer = requestAnimationFrame(redraw);
	}
	redraw();
	
	c.addEventListener('mousedown',function(evt){
		lastX = evt.offsetX || (evt.pageX - c.offsetLeft);
		lastY = evt.offsetY || (evt.pageY - c.offsetTop);
		dragStart = t.transformedPoint(lastX,lastY);
		dragged = false;
	},false);
	c.addEventListener('mousemove',function(evt){
		lastX = evt.offsetX || (evt.pageX - c.offsetLeft);
		lastY = evt.offsetY || (evt.pageY - c.offsetTop);
		dragged = true;
		if (dragStart){
			var pt = t.transformedPoint(lastX,lastY);
			t.translate(pt.x-dragStart.x,pt.y-dragStart.y);
		}
	},false);
	c.addEventListener('mouseup',function(evt){
		dragStart = null;
		if (!dragged) zoom(evt.shiftKey ? -1 : 1 );
	},false);
	function zoom(clicks){
		var pt = t.transformedPoint(lastX,lastY);
		t.translate(pt.x,pt.y);
		var factor = Math.pow(scaleFactor,clicks);
		t.scale(factor,factor);
		t.translate(-pt.x,-pt.y);
	}
	addWheelListener(c,function(evt){
		zoom(evt.deltaY / 100);
		return evt.preventDefault() && false;
	});
	window.addEventListener('resize',function(evt){
		c.width = width = window.innerWidth;
		c.height = height = window.innerHeight;
	});
	document.addEventListener('keydown',function(evt){
		if(!evt.keyCode)keyspressed[evt.keyCode] = 1;
		else keyspressed[evt.keyCode] += 0.01;
	});
	document.addEventListener('keyup',function(evt){
		keyspressed[evt.keyCode] = 0;
	});
	// Adds t.getTransform() - returns an SVGMatrix
	// Adds t.transformedPoint(x,y) - returns an SVGPoint
	function trackTransforms(t){
		var svg = document.createElementNS("http://www.w3.org/2000/svg",'svg');
		var xform = svg.createSVGMatrix();
		t.getTransform = function(){ return xform; };
		var savedTransforms = [];
		var save = t.save;
		t.save = function(){ savedTransforms.push(xform.translate(0,0)); return save.call(t); };
		var restore = t.restore;
		t.restore = function(){ xform = savedTransforms.pop(); return restore.call(t); };
		var scale = t.scale;
		t.scale = function(sx,sy){ xform = xform.scaleNonUniform(sx,sy); return scale.call(t,sx,sy); };
		var rotate = t.rotate;
		t.rotate = function(radians){ xform = xform.rotate(radians*180/Math.PI); return rotate.call(t,radians); };
		var translate = t.translate;
		t.translate = function(dx,dy){ xform = xform.translate(dx,dy); return translate.call(t,dx,dy); };
		var transform = t.transform;
		t.transform = function(a,b,c,d,e,f){ var m2 = svg.createSVGMatrix(); m2.a=a; m2.b=b; m2.c=c; m2.d=d; m2.e=e; m2.f=f;
			xform = xform.multiply(m2); return transform.call(t,a,b,c,d,e,f); };
		var setTransform = t.setTransform;
		t.setTransform = function(a,b,c,d,e,f){ xform.a = a; xform.b = b; xform.c = c; xform.d = d; xform.e = e;
			xform.f = f; return setTransform.call(t,a,b,c,d,e,f); };
		var pt = svg.createSVGPoint();
		t.transformedPoint = function(x,y){ pt.x=x; pt.y=y; return pt.matrixTransform(xform.inverse()); }
	}
	t.scale(10,10);
	</script>
</body>