<!DOCTYPE html>
<html>
<head>
	<title>Annext</title>
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
	<link href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.98.2/css/materialize.min.css" rel="stylesheet" type="text/css" />
	<link href="favicon.ico" rel="icon" type="image/x-icon" />
	<script type="text/javascript" src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.98.2/js/materialize.min.js"></script>
	<script type="text/javascript" src="js/wordgen.min.js"></script>
	<script type="text/javascript" src="js/graphs.js"></script>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	<style type="text/css">
	body {
		position: absolute;
		left: 0;
		right: 0;
		top: 0;
		bottom: 0;
		margin: 0;
		background-color: #000;
		font-family: Roboto, Helvectica, sans-serif;
		overflow: hidden;
	}
	body > div {
		position: absolute;
		left: 0;
		top: 0;
		width: 100%;
		height: 100%;
		margin: 0;
	}
	#game { left: 100%; }
	.display { position: absolute; left: 0; width: 100%; text-align: center; color: #fff; }
	h1.display { top: 0; font-size: 112px !important; font-weight: 300 !important; }
	h4.display { top: 144px; }
	.preloader-wrapper {
		position: absolute;
		left: 50%;
		top: 50%;
		margin-left: -24px;
		margin-top: -64px;
	}
	#games {
		position: absolute;
		left: 20%;
		right: 20%;
		top: 240px;
		overflow-y: auto;
		display: none;
	}
	#x { display: inline-block; transition: transform 200ms; }
	h1.display:hover > #x { transform: rotateY(180deg); }
	#start {
		position: absolute;
		top: 256px;
		left: 0;
		right: 0;
		bottom: 0;
	}
	#join { margin-right: -32px; margin-top: -8px; }
	#credits {
		position: absolute;
		bottom: 0;
		width: 100%;
		text-align: center;
		color: white;
	}
	.input-field input[type=text]:focus + label { color: #E91E63; }
	.input-field input[type=text]:focus {
		border-bottom: 1px solid #E91E63;
		box-shadow: 0 1px 0 0 #E91E63;
	}
	#logo { padding-left: 8px; padding-top: 8px; }
	#action { display: none; transition: margin-right 200ms ease-out; }
	#action.shifted { margin-right: 400px; }
	#closeChat {
		width: 64px;
		height: 64px;
		text-align: center;
		padding: 0 !important;
	}
	#leftTabs {
		position: relative;
		display: inline-block;
		left: 0;
		top: 0;
		width: auto;
		overflow-x: visible;
	}
	#leftTabs ul, #leftTabs li { height: 64px; }
	#leftTabs a {
		height: 64px;
		padding: 8px 24px;
		box-sizing: border-box;
	}
	.indicator { min-width: 72px; }
	.tabcontent {
		position: absolute;
		left: 0;
		top: 64px;
		right: 0;
		bottom: 0;
	}
	#map {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
	}
	#c {
		position: absolute;
		left: 0;
		top: 0;
		width: 100%;
		height: 100%;
		background-color: rgb(6, 16, 36);
		background-image: url('images/universe.jpg');
		background-repeat: no-repeat;
		background-size: cover;
		background-position: 0 0;
	}
	#historyGraph, #statsGraph { border: 2px solid white; }
	#historyGraphTitle, #statsTitle { width: 216px; }
	#sidenav-overlay { display: none !important; }
	#msg {
		position: absolute;
		top: 64px;
		bottom: 108px;
		width: 100%;
		overflow-y: auto;
	}
	#msg .col { width: 364px; }
	#msg .col.icon { width: 36px; padding: 0 6px; }
	#msg .circle {
		min-width: 36px;
		width: 36px;
		height: 36px;
		text-align: center;
		font-size: 12px;
		padding: 8px 0;
		display: inline-block;
	}
	#typingArea {
		width: 100%;
		height: 48px;
		position: absolute;
		bottom: 48px;
	}
	#ctxmenu {
		position: fixed;
		display: none;
		z-index: 99;
	}
	#missileLaunchButton, #bombButton {
		position: absolute;
		top: 0%;
		left: 41%;
		padding: 10px;
		color: white;
		width: 18%;
		text-align: center;
		display: none;
	}
	</style>
	<script type="text/javascript">
	(function(window,document) {
		var prefix = "", _addEventListener, support;
		if ( window.addEventListener ) _addEventListener = "addEventListener"; // detect event model
		else {
			_addEventListener = "attachEvent";
			prefix = "on";
		}
		// detect available wheel event
		support = "onwheel" in document.createElement("div") ? "wheel" : // Modern browsers support "wheel"
			document.onmousewheel !== undefined ? "mousewheel" : // Webkit and IE support at least "mousewheel"
			"DOMMouseScroll"; // let's assume that remaining browsers are older Firefox
		window.addWheelListener = function( elem, callback, useCapture ) {
			_addWheelListener( elem, support, callback, useCapture );
			// handle MozMousePixelScroll in older Firefox
			if( support == "DOMMouseScroll" ) _addWheelListener( elem, "MozMousePixelScroll", callback, useCapture );
		};
		function _addWheelListener( elem, eventName, callback, useCapture ) {
			elem[ _addEventListener ]( prefix + eventName, support == "wheel" ? callback : function( originalEvent ) {
				!originalEvent && ( originalEvent = window.event );
				var event = { // create a normalized event object
					originalEvent: originalEvent, // keep a ref to the original event object
					target: originalEvent.target || originalEvent.srcElement,
					type: "wheel",
					deltaMode: originalEvent.type == "MozMousePixelScroll" ? 0 : 1,
					deltaX: 0,  deltaY: 0,  deltaZ: 0,
					preventDefault: function() {
						originalEvent.preventDefault ?
							originalEvent.preventDefault() :
							originalEvent.returnValue = false;
					}
				};
				if ( support == "mousewheel" ) { // calculate deltaY (and deltaX) according to the event
					event.deltaY = - 1/40 * originalEvent.wheelDelta;
					originalEvent.wheelDeltaX && ( event.deltaX = -1/40 * originalEvent.wheelDeltaX ); // Webkit also support wheelDeltaX
				} else event.deltaY = originalEvent.detail;
				return callback( event ); // it's time to fire the callback
			}, useCapture || false );
		}
	})(window,document);
	function trackTransforms(t){ // Credit goes to http://phrogz.net/tmp/canvas_zoom_to_cursor.html
		let svg = document.createElementNS('http://www.w3.org/2000/svg','svg'),
		xform = svg.createSVGMatrix(),
		savedTransforms = [], save = t.save, restore = t.restore, scale = t.scale, rotate = t.rotate,
		translate = t.translate, transform = t.transform,
		setTransform = t.setTransform, pt = svg.createSVGPoint();
		t.getTransform = function(){ return xform; };
		t.save = function(){ savedTransforms.push(xform.translate(0,0)); return save.call(t); };
		t.restore = function(){ xform = savedTransforms.pop(); return restore.call(t); };
		t.scale = function(sx,sy){ xform = xform.scaleNonUniform(sx,sy); return scale.call(t,sx,sy); };
		t.rotate = function(radians){ xform = xform.rotate(radians*180/Math.PI); return rotate.call(t,radians); };
		t.translate = function(dx,dy){ xform = xform.translate(dx,dy); return translate.call(t,dx,dy); };
		t.transform = function(a,b,c,d,e,f){ var m2 = svg.createSVGMatrix(); m2.a=a; m2.b=b; m2.c=c; m2.d=d; m2.e=e; m2.f=f;
			xform = xform.multiply(m2); return transform.call(t,a,b,c,d,e,f); };
		t.setTransform = function(a,b,c,d,e,f){ xform.a = a; xform.b = b; xform.c = c; xform.d = d; xform.e = e;
			xform.f = f; return setTransform.call(t,a,b,c,d,e,f); };
		t.transformedPoint = function(x,y){ pt.x=x; pt.y=y; return pt.matrixTransform(xform.inverse()); };
		t.originalPoint = function(x,y){ pt.x=x; pt.y=y; return pt.matrixTransform(xform); };
	}
	</script>
</head>
<body>
	<div id="imageSources" style="display:none;">
		<img id="spritesheet"></img>
	</div>
	<div id="home">
		<h1 class="display">Anne<img id="x" src="./images/x.png" width="69" height="60" alt="x" />t</h1>
		<h4 class="display">Next Level World Domination</h4>
		<div id="start">
			<div class="row">
				<div class="col s2 offset-s3 white-text"><h4 style="text-align: right;">ws://</h4></div>
				<div class="col s1 input-field white-text">
					<input type="text" id="url" class="validate" required="required" placeholder="Server code" maxlength="8" size="8" pattern="^[a-f\d]{8}$" data-error="Invalid code" data-successs="Looks good!" />
				</div>
				<div class="col s2 white-text">
					<h4>.ngrok.io <a id="join" class="btn-floating btn-large waves-effect waves-light pink right"><i class="material-icons">arrow_forward</i></a></h4>
				</div>
			</div>
			<div class="row">
				<div class="col s2 offset-s5 center-align">
					<a href="#" class="btn btn-large waves-effect waves-light indigo white-text">Manual</a>
				</div>
			</div>
		</div>
		<p id="credits">&copy; 2017 Annext by <a class="pink-text" href="http://github.com/CharCoding/" title="GitHub">CharCoding</a>, All Rights Reserved.</p>
	</div>
	<div id="game">
		<nav class="nav">
			<div class="nav-wrapper indigo">
				<div id="leftTabs">
					<ul id="nav-content" class="left tabs tabs-transparent indigo">
        		<li class="tab"><a id="mapButton" href="#map">MAP</a></li>
        		<li class="tab"><a id="historyButton" href="#history">HISTORY</a></li>
        		<li class="tab"><a id="statsButton" href="#stats">STATS</a></li>
        		<li class="tab disabled"><a href="#battle">BATTLE</a></li>
      		</ul>
      	</div>
				<a href="#" class="brand-logo center">
					<span id="countryName"></span>
				</a>
				<ul class="right">
					<li><a href="#settingsModal" id="settingsBtn"><i class="material-icons left">settings</i>Settings</a></li>
					<li><a href="#!"><i class="material-icons left">launch</i>Manual</a></li>
					<li><a href="#!" id="chatBtn" data-activates="chat"><i class="material-icons right">chat</i>Chat</a></li>
				</ul>
			</div>
		</nav>
		<div id="map" class="col s12 tabcontent">
			<div id="ctxmenu" class="card">
				<div id="card-content">
					<span class="card-title" id="ctxmenutitle">Sector ??</span>
					<div id="economymenu">
						<div class="row" id="economymenuContainer">
							<div class="col s3" id="buildingBuildMenu"></div>
							<div class="col s3" id="unitBuildMenu"></div>
							<div class="col s3" id="airUnitBuildMenu"></div>
							<div class="col s3" id="resourceBuildMenu"></div>
							<div class="col s3" id="missileBuildMenu"></div>
						</div>
					</div>
				</div>
			</div>
			<div class="row">
				<a id="missileLaunchButton" class="waves-effect waves-light red" onclick="selected.confirmLaunch()">LAUNCH NUCLEAR WEAPONS</a>
				<a id="bombButton" class="waves-effect waves-light orange" onclick="selected.bomb()" style="display: none;">CONDUCT STRATEGIC BOMBING</a>
				<canvas id="c"></canvas>
			</div>
			<div class="row">
					<div class="card pink" style="position:fixed; bottom:0; margin-bottom:0;width:45%;">
						<div class="card-content white-text" style="padding: 10px;">
							<div class="col s3">
								<span id="infoCurrentTurn" class="card-title">Turn 0</span>
					      <input type="checkbox" id="nextTurnCheckbox" />
					      <label for="nextTurnCheckbox">Ready</label>
							</div>
							<div class="col s3">
								<p id="info-development"><i class="material-icons">receipt</i>0/0</p>
								<p id="reconstituted-cities"></p>
							</div>
							<div class="col s2">
								<p id="info-steel"><i class="material-icons">view_week</i>0</p>
							</div>
							<div class="col s2">
								<p id="info-oil"><i class="material-icons">invert_colors</i>0</p>
							</div>
							<div class="col s2">
								<p id="info-uranium"><img src="images/radioactive.png" width="24" height="24"></i>0</p>
								<a class="waves-effect waves-effect btn-flat" onclick="players[0].unenrichUranium()" style="font-size: 10px; padding: 5px;">Deconvert</a>
							</div>
						</div>
					</div>
				</div>
			</div>
			<div id="action" class="fixed-action-btn horizontal">
				<a class="btn-floating btn-large pink waves-effect waves-light">
					<i class="large material-icons">add</i>
				</a>
				<ul>
					<li>
						<a id="cityBtn" class="btn-floating blue-grey waves-effect waves-light">
							<i class="material-icons">location_city</i>
						</a>
					</li>
					<li>
						<a id="militaryBtn" class="btn-floating red waves-effect waves-light">
							<i class="material-icons">gps_fixed</i>
						</a>
					</li>
					<li>
						<a id="buildBtn" class="btn-floating yellow darken-1 waves-effect waves-light">
							<i class="material-icons">build</i>
						</a>
					</li>
					<li>
						<a id="tradeBtn" class="btn-floating green waves-effect waves-light">
							<i class="material-icons">attach_money</i>
						</a>
					</li>
				</ul>
			</div>
		</div>
		<div id="history" class="col s12 tabcontent black">
			<div class="container">
				<br>
				<center><a id="historyGraphTitle" class="dropdown-button btn pink" data-activates="historyGraphSelector">Development</a></center>
				<ul id='historyGraphSelector' class='dropdown-content indigo-text'>
					<li><a class="indigo-text">Development</a></li>
					<li><a class="indigo-text">Population</a></li>
					<li><a class="indigo-text">Steel Production</a></li>
					<li><a class="indigo-text">Oil Production</a></li>
					<li><a class="indigo-text">Air Units</a></li>
					<li><a class="indigo-text">Land Units</a></li>
					<li><a class="indigo-text">Sea Units</a></li>
					<li><a class="indigo-text">Nuclear Weapons</a></li>
			 </ul>
			 <canvas id="historyGraph"></canvas>
			</div>
		</div>
		<div id="stats" class="col s12 tabcontent black">
			<br>
			<center><a id="statsTitle" class="dropdown-button btn pink" data-activates="statsSelector">Development</a></center>
			<ul id='statsSelector' class='dropdown-content indigo-text'>
				<li><a class="indigo-text">Development</a></li>
				<li><a class="indigo-text">Population</a></li>
				<li><a class="indigo-text">Steel Production</a></li>
				<li><a class="indigo-text">Oil Production</a></li>
				<li><a class="indigo-text">Air Units</a></li>
				<li><a class="indigo-text">Land Units</a></li>
				<li><a class="indigo-text">Sea Units</a></li>
				<li><a class="indigo-text">Tiles</a></li>
				<li><a class="indigo-text">Nuclear Weapons</a></li>
		 </ul></center>
		 <br>
		 <div class="row">
			 <div class="col s6">
				 <table id="statsTable" class="highlight white-text">
					 <thead>
						 <tr>
							 <th>Player</th>
							 <th id="statsTableHeading">Development</th>
							 <th id="statsTablePercentHeading">% of World Development</th>
						 </tr>
					 </thead>
					 <tbody id="statBody">
					 </tbody>
				 </table>
			 </div>
			 <div class="col s6">
				 <canvas id="statsGraph"></canvas>
			 </div>
			</div>
		</div>
		<div id="battle" class="col s12 tabcontent">
		</div>
		<div id="chat" class="side-nav">
			<nav class="nav">
				<div class="nav-wrapper indigo">
					<a href="#" class="brand-logo">
						&nbsp; Chat
					</a>
					<a href="#" id="closeChat" class="valign-wrapper btn-flat white-text right"><i class="material-icons">close</i></a>
				</div>
			</nav>
			<div id="msg">
				<div class="row valign-wrapper">
					<div class="col icon">
						<div class="circle grey darken-4 white-text">game</div>
					</div>
					<div class="col">
						Welcome to Annext. If you do not know how to play, consult the manual. Or don't, and learn by trial and error (mostly error).
					</div>
				</div>
				<div class="row valign-wrapper">
					<div class="col icon">
						<div class="circle grey darken-4 white-text">game</div>
					</div>
					<div class="col">
						Your objective is simple - conquer the world using any means necessary. But do keep in mind that it is only a game. The Annext dev team takes no responsiblity for any actual wars sparked by this game.
					</div>
				</div>
				<div class="row valign-wrapper">
					<div class="col icon">
						<div class="circle grey darken-4 white-text">game</div>
					</div>
					<div class="col">
						The chat supports Skype text formatting (* for bold, ~ for strikethrough, _ for italics, etc.). Please be civil in the chat.
					</div>
				</div>
				<div class="row valign-wrapper">
					<div class="col icon">
						<div class="circle grey darken-4 white-text">game</div>
					</div>
					<div class="col">
						Good luck (if you need it). As Winston Churchill once said: "Success is not final, failure is not fatal: it is the courage to continue that counts." Or, as Napoleon Bonaparte put it: "Glory is fleeting, but obscurity is forever."
					</div>
				</div>
			</div>
			<div id="typingArea" class="row">
				<div class="divider"></div>
				<div class="col s12">
					<input id="chatInput" style="border: none !important; box-shadow: none !important;" placeholder="Your message" type="text" maxlength="256" />
				</div>
			</div>
		</div>
		<div id="countryModal" class="modal">
			<div class="modal-content">
				<h4>Name of Your Country:</h4>
				<div class="row">
					<div class="col s6 input-field">
						<input id="countryInput" class="validate" type="text" required="required" maxlength="32" pattern="^[A-Za-z][A-Za-z ]+$" data-error="Invalid country name" data-success="Sounds great!" /><label for="country">Country Name:</label>
					</div>
					<div class="col s6">
						<a id="generateName" class="btn waves-effect waves-light pink white-text">GENERATE <i class="material-icons right">refresh</i></a>
					</div>
				</div>
				<div class="row">
					<div class="col s12">Try to come up with a name that doesn't reveal your identity, so that the game can be less personal.<br />A country name can only contain letters and spaces.<br />You CANNOT change the country name once you press CONFIRM.</div>
				</div>
			</div>
			<div class="modal-footer">
				<a href="#!" id="submitName" class="disabled btn modal-action modal-close waves-effect waves-light indigo white-text">CONFIRM</a>
			</div>
		</div>
		<div id="settingsModal" class="modal">
		 <div class="modal-content">
			 <h4>Settings</h4>
			 <div class="input-field col s12">
				<select id="settingsIconSelect">
					<option value="icon" onclick="loadIconSet('icons_default')">Default</option>
					<option value="NATO" onclick="">NATO Icons</option>
				</select>
				<label>ICON SET</label>
			</div>
			<p>Zoom:</p>
			<div id="settingsInvertZoom" class="switch">
		    <label>
		      Normal Zoom
		      <input type="checkbox">
		      <span class="lever"></span>
		      Invert Zoom
		    </label>
		  </div>
			<p>Infinite map scroll:</p>
			<div id="settingsInfiniteScroll" class="switch">
		    <label>
		      Disabled
		      <input type="checkbox">
		      <span class="lever"></span>
		      Enabled (WARNING: EXPERIMENTAL)
		    </label>
		  </div>
			<p>Strategic map view (tiles colored with player color instead of terrain color when zoomed out):</p>
			<div id="settingsStrategicMapView" class="switch">
		    <label>
		      Disabled
		      <input type="checkbox">
		      <span id="settingsStrategicMapViewLever" class="lever"></span>
		      Enabled
		    </label>
		  </div>
		 </div>
		 <div class="modal-footer">
			 <a href="#!" class="modal-action modal-close waves-effect waves-green btn-flat">Close</a>
		 </div>
	 </div>
	</div>
	<script type="text/javascript">
	$(document).ready(function(){
		const countryRegex = /^[a-z]+( ?[a-z']+)+ ?[a-z]$/i;
		$('#countryInput').on('change input',function(){
			let val = $(this).val();
			if(val.length > 3 && val.length < 33 && countryRegex.test(val)) $('#submitName').removeClass('disabled');
			else $('#submitName').addClass('disabled');
		});
		$('#join').on('click',function(){
			$('#home').animate({"left": "-100%"}, 400);
			$('#game').animate({"left": "0"}, 400);
			$('#countryModal').modal({dismissible: false, inDuration: 250, complete: function() {
				players.push(new Player($('#countryInput').val().capitalize()));
				players[0].updateInfoBar();
				$('#countryName').text(players[0].name);
				$('#countryModal').remove();
				loadRenderTests(); //for testing
				// TODO: Send country object to server
			}});
			$('#countryModal').modal('open');
			$('#action,#navigator').fadeIn(400);
			draw();
		});
		$('#chatBtn').on('click',function(){
			$('#action').addClass('shifted');
		}).sideNav({
			menuWidth: 400,
			edge: 'right',
			closeOnClick: false,
			draggable: false
		});
		$('#closeChat').on('click',function(){
			$('#action').removeClass('shifted');
			$('#chatBtn').sideNav('hide');
		});
		$('#generateName').on('click',function(){
			$('#countryInput').val(word(2,1).capitalize());
			$('#submitName').removeClass('disabled');
			Materialize.updateTextFields();
		});
		$('#settingsModal').modal({
			dismissible: true,
			opacity: .5,
		});
		$('#settingsIconSelect').on('change', function(evt) {
			if (evt.target.innerHTML = "NATO Icons") { //TEMPORARY - remove once NATO icons are updated
				alert('The creator of the NATO icon set has not yet updated it to support the latest version of Annext');
				return;
			}
			loadIconSet(evt.target.value);
		});
		$('#settingsInvertZoom').on('change', function(evt) {
			zoomDirection *= -1;
		});
		$('#settingsInfiniteScroll').on('change', function(evt) {
			useInfiniteScroll = !useInfiniteScroll;
		});
		$('#settingsStrategicMapView').on('change', function(evt) {
			enableStrategicMapView = !enableStrategicMapView;
		});
		$('#nextTurnCheckbox').on('change', function(evt) {
			nextTurnCheckbox.checked = !nextTurnCheckbox.checked;
			gameState.nextRound(); //once server functionality exists add check for all other players having moved
		});
		$('select').material_select();
		$('#historyGraphSelector').on('click', function(evt) {
			if(evt.target.tagName != 'A') return; // sometimes it selects the outer <ul> as target
			var type = evt.target.innerHTML;
			historyGraphTitle.innerHTML = type;
			//drawGraph(historyGraph.getContext('2d'), getDataSet(type, players), "line", true)
		});
		$('#statsSelector').on('click', function(evt) {
			if(evt.target.tagName != 'A') return;
			var type = evt.target.innerHTML;
			statsTitle.innerHTML = type;
			statsTableHeading.innerHTML = type;
			statsTablePercentHeading.innerHTML = "% of World " + type;
		});
		Materialize.updateTextFields();
		//GRAPH TESTS (remove after functionality for getting player data is in place):
		drawGraph(historyGraph.getContext('2d'), testDataSet, "line", true);
		drawGraph(statsGraph.getContext('2d'), testDataSet, "pie", true);
	});
	let width = window.innerWidth, height = window.innerHeight - 64, //height of top tab
	keys = new Array(100).fill(0), timer,  mapSize = 25, moved = true,
	zoomDirection = 1,
	iconSize = 5,
	enableStrategicMapView = true,
	useInfiniteScroll = false,
	iconSet = "icon",
	unitTypeNames = ["Infantry", "MechanizedInfantry", "Tank", "Artillery",
		"Destroyer", "Cruiser", "Battleship", "Submarine", "AircraftCarrier", "Transport",
		"Fighter", "Bomber", "MRBM", "ICBM", "MRBMlaunched", "ICBMlaunched"/*, "Helicopter"*/],
	landUnitTypeNames = ["Infantry", "Artillery", "MechanizedInfantry", "Tank"],
	airUnitTypeNames = ["Fighter", "Bomber"],
	seaUnitTypeNames = ["AircraftCarrier", "Battleship", "Cruiser", "Destroyer", "Submarine", "Transport"],
	missileTypeNames = ["MRBM", "ICBM"],
	launchedMissileTypeNames = ["MRBMlaunched", "ICBMlaunched"],
	buildingTypeNames = ["OilRig", "Mine", "UraniumMine", "UraniumRefinery"],
	resourceTypeNames = ["oil", "steel", "uranium"],
	specialIcons = ["damage"],
	typeCategories = [seaUnitTypeNames, landUnitTypeNames, airUnitTypeNames, missileTypeNames, launchedMissileTypeNames, buildingTypeNames, resourceTypeNames, launchedMissileTypeNames, specialIcons], //for finding icon in sprite
	terrainTypeNames = ["sea", "plains", "desert", "mountains"],
	materialResourceIcons = { //material icons used for each resource. Do they make sense? No.
		development : "receipt",
		steel : "view_week",
		oil : "invert_colors",
		uranium : ""
	},
	defaultResourceQuantity = Infinity,
	resourceNames = ["development", "steel", "oil", "uranium", "enrichedUranium"];
	c.width = width;
	c.height = height;
	const scaleFactor = 1.04, t = c.getContext('2d'), hgraph = historyGraph.getContext('2d'),
	r = 16, colors = ["#003fcf","#00ff3f","#cfcf00","#7f7f7f", "#f96100"],
	MDcolors = [],
	map = new Array(mapSize), mouse = {
		x: width / 2, y: height / 2, dragged: false, dragStart: null, scale: 1
	}, players = [];
	settingsStrategicMapViewLever.click();
	trackTransforms(t);
	historyGraph.width = width / 1.5; historyGraph.height = height / 1.5;
	statsGraph.width = width / 2.5; statsGraph.height = height / 2;
	hgraph.fillStyle = "red";
	hgraph.fillText("NO DATA", historyGraph.width / 2, historyGraph.height / 2);
	t.strokeStyle = "#000";
	t.lineCap = "square";
	t.lineWidth = 2;
	t.translate(width / 2, height / 2);
	function removeAllChildNodes(el) {
		while (el.firstChild) {
			el.removeChild(el.firstChild);
		}
	}
	function loadIconSet(setName) {spritesheet.src = "images/" + setName + ".png";}
	loadIconSet("icons_default");
	function getColorFromScale(start, end, pos) {
		pos = Math.max(0, Math.min(1, pos));
	  var re = new RegExp(/^#(?:[0-9a-f]{3}){1,2}$/i); //thanks Google
	  if (!(re.test(start) && re.test(end))) return end;
	  function prism(color) {
	    var col = color.substring(1,color.length), arr = [];
	    for (var i=0; i<3; i++) {
	      arr.push(parseInt(col.substring(i * 2, i * 2 + 2), 16));
	    }
	    return arr;
	  }
	  var s = prism(start), e = prism(end), x = [];
	  for (var i=0;i<s.length;i++){
	    x.push(Math.round( s[i] + pos*(e[i] - s[i]) ));
	    x[i] = Math.max(0, Math.min(x[i], 255));
	    x[i] = x[i].toString(16);
	    if (x[i].length < 2) x[i] = "0" + x[i];
	  }
	  return "#" + x.join("");
	}
	function hexCoordToPoint(x, y) {
		return [(x + y) * r * 1.5, (y - x) * r * .866];
	}
	function pixelToHex(x, y) {
		return [(x - 1.732 * y) / r / 3, (x + 1.732 * y) / r / 3];
	}
	function removeMultipleFromArrayByProp(arr, propName, propValue, propName2, propValue2) {
		let removeIndexes = [];
		for (let i = 0; i < arr.length; i++) {
			if (arr[i][propName] == propValue && (arr[i][propName2] == propValue2 || propName2 == undefined)) {
				removeIndexes.push(i);
			}
		}
		for (let i = removeIndexes.length - 1; i >= 0; i--) {
			arr.splice(removeIndexes[i], 1);
		}
		return arr;
	}
	var selected = {
		units : [],
		tile : {units : [], hexesWithinDist : function() {return [];}}, //avoid errors
		moveTo : function(hex) {
			var unselected = [];
			for (let i = 0; i < selected.tile.units.length; i++) {
				if (!selected.tile.units[i].selected) unselected.push(selected.tile.units[i]);
			}
			selected.tile.units = unselected;
			hex.units = hex.units.concat(selected.units);
			for (let i = 0; i < selected.units.length; i++) {
				selected.units[i].movesLeft -= selected.tile.distanceTo(hex.x, hex.y);
			}
			for (let i = selected.units.length - 1; i >= 0; i--) {
				if (selected.units[i].typeName == "MRBMlaunched") {
					hex.nuke();
					selected.units.splice(i, 1);
					hex.units.splice(hex.units.indexOf(selected.units[i]), 1);
				}
			}
			selected.clear();
			if (selected.tile.owner) selected.tile.owner.updateOwnedTiles();
		},
		clear : function() {
			this.hideLaunchOption();
			this.hideBombOption();
			for (let i = 0; i < this.units.length; i++) {
				this.units[i].selected = false;
			}
			this.units = [];
			this.refreshMoves();
		},
		selectAllFromTile : function(hex) {
			this.clear();
			this.tile = hex;
			for (let i = 0; i < this.tile.units.length; i++) {
				this.tile.units[i].selected = true;
				this.units.push(this.tile.units[i]);
			}
			this.refreshMoves();
		},
		refreshMoves : function() {
			if (this.units.length === 0) {
				this.canMoveTo = [];
				return;
			}
			this.canMoveTo = this.tile.hexesWithinDist(this.moveRange(), this.moveBiomes());
		},
		moveRange : function() {
			var min = 999;
			for (let i = 0; i < this.units.length; i++) {
				min = Math.min(min, this.units[i].movesLeft);
			}
			return min;
		},
		moveBiomes : function() {
			var biomes = new Array(colors.length);
			biomes.fill(true);
			for (let i = 0; i < this.units.length; i++) {
				for (let j = 0; j < colors.length; j++) {
					if (!this.units[i].canMove[j]) biomes[j] = false;
				}
			}
			return biomes;
		},
		canMoveTo : [],
		unitsOfType : function(typeName) {
			let sum = 0, r = [];
			for (let i = 0; i < this.units.length; i++) {
				if (this.units[i].typeName == typeName) ++sum;
			}
			return sum;
		},
		selectUnit : function(unit, hexx, hexy, selectAll) {
			if (selected.tile.x == hexx && selected.tile.y == hexy) {
				for (let i = 0; i < this.tile.units.length; i++) {
					if (this.tile.units[i].typeName == unit.typeName && this.tile.units[i].selected == false) {
						this.tile.units[i].selected = true;
						this.units.push(this.tile.units[i]);
						if (unit.category == 3) selected.showLaunchOption();
						if (unit.typeName == "Bomber" && unit.movesLeft > 2) selected.showBombOption();
						if (!selectAll) return;
					}
				}
			} else { //if unit is on different tile
				this.clear();
				this.tile = map[hexx][hexy];
				unit.selected = true;
				this.units.push(unit);
			}
			if (selectAll) { //shift-click adds all of a type
				for (let i = 0; i < this.tile.units.length; i++) {
					if (this.tile.units[i].typeName == unit.typeName && this.tile.units[i].selected == false) {
						this.tile.units[i].selected = true;
						this.units.push(this.tile.units[i]);
					}
				}
			}
			if (unit.category == 3) selected.showLaunchOption();
			if (unit.typeName == "Bomber" && unit.movesLeft > 2) selected.showBombOption();
			this.refreshMoves();
		},
		hideLaunchOption : function() {missileLaunchButton.style.display = "none";},
		showLaunchOption : function() {missileLaunchButton.style.display = "inline";},
		hideBombOption : function() {bombButton.style.display = "none";},
		showBombOption : function() {
			bombButton.innerHTML = "CONDUCT BOMBING RAID (" + this.unitsOfType("Bomber") + " bombers)";
			bombButton.style.display = "inline";
		},
		confirmLaunch : function() {
			if (confirm("You are about to launch " + this.unitsOfType("ICBM") + " ICBMs and " + selected.unitsOfType("MRBM") + " MRBMs. Are you sure you wish to proceed?")) {
				selected.launch();
			} else alert("Nuclear war averted. For now.");
		},
		launch : function() {
			let missileArray = [], launched = [];
			for (let i = 0; i < this.units.length; i++) {
				if (this.units[i].category == 3) missileArray.push(this.units[i]);
			}
			let owner = missileArray[0].owner;
			removeMultipleFromArrayByProp(this.tile.units, "category", 3, "selected", true);
			this.clear();
			for (let i = 0; i < missileArray.length; i++) {
				launched.push(new Unit(missileArray[i].typeName + "launched", owner));
			}
			selected.tile.units = selected.tile.units.concat(launched);
		},
		bomb : function() {
			let num = 0;
			for (let i = 0; i < this.units.length; i++) {
				if (this.units[i].typeName == "Bomber" && this.units[i].movesLeft > 2) {
					++num;
					this.units[i].movesLeft -= 2;
				}
			}
			this.tile.bomb(num);
		}
	},
	gameState = {
		turn : 0,
		nextRound : function() {
			for (let i = 0; i < players.length; i++) {
				players[i].nextTurn();
				if (players[i].uranium > 0) {
					players[i].development += Math.round(Math.log(players[i].uranium) * 4);
				}
			}
			players[0].updateInfoBar();
			++gameState.turn;
			infoCurrentTurn.innerHTML = "Turn " + gameState.turn;
			let nukeList = [];
			for (let x = 0; x < map.length; x++) {
				for (let y = 0; y < map.length; y++) {
					for (let i = map[x][y].units.length - 1; i >= 0; i--) {
						map[x][y].units[i].movesLeft = map[x][y].units[i].move;
						if (launchedMissileTypeNames.indexOf(map[x][y].units[i].typeName) != -1) {
							--map[x][y].units[i].timeUntilDetonation;
							if (map[x][y].units[i].timeUntilDetonation < 0) {
								nukeList.push(map[x][y]);
								map[x][y].units.splice(i, 1);
							}
						}
					}
					if (map[x][y].type == 4 && Math.random() > 0.7) {
						map[x][y].type = 2;
						map[x][y].color = colors[2];
					} else if (map[x][y].type == 4) {
						map[x][y].mines = 0;
						map[x][y].uraniumMines = 0;
						map[x][y].uraniumRefineries = 0;
						map[x][y].oilRigs = 0;
						map[x][y].cities = Math.max(map[x][y].cities - 1, 0);
					}
					map[x][y].killUnbasedUnits();
					if (map[x][y].damage >= 3) {
						while (map[x][y].damage >= 3) {
							map[x][y].damage -= 2;
							let building = map[x][y].getRandomBuilding();
							if (building != undefined) {
								--map[x][y][building];
							} else if(map[x][y].cities > 0) {
								--map[x][y].cities;
							} else {
								map[x][y].damage = 0;
							}
						}
					} else if (map[x][y].damage > 0) {
						++map[x][y].damage;
					}
				}
			}
			for (let i = 0; i < nukeList.length; i++) nukeList[i].nuke();
			moved = true;
		}
	}
	class Hex {
		constructor(x, y, type){
			this.type = type;
			this.color = colors[type];
			this.x = x;
			this.y = y;
			this.owner = null;
			this.ownerColor = "#0000ff";
			this.cities = 0;
			this.mines = 0;
			this.oilRigs = 0;
			this.uraniumMines = 0;
			this.uraniumRefineries = 0;
			this.units = [];
			this.isCapital = false;
			this.development = Infinity; //reserves of each resource
			this.steel = 0; //resource amounts set during map gen
			this.oil = 0;
			this.uranium = 0;
			this.steelSources = 0; //number of sources of each resource - determines how fast resource depletes
			this.oilSources = 0;
			this.uraniumSources = 0;
			this.damage = 0;
			this.hexDisp = { //unit display locations specified in unit objects
				mines : [-1, 1],
				oilRigs : [0, 1],
				uraniumMines : [-1, 0],
				uraniumRefineries : [1, 0],
				steel : [-2, 2],
				uranium : [-1, 2],
				oil : [0, 2]
			}
			this.renderWhere = []; //for rendering a hex multiple times for infinite scroll
			return map[x][y] = this;
		}
		get neighbors(){
			return [ // does this really work?
				map[mod(this.x + 1, mapSize)][this.y],
				map[mod(this.x + 1, mapSize)][mod(this.y - 1, mapSize)],
				map[this.x][mod(this.y - 1, mapSize)],
				map[mod(this.x - 1, mapSize)][this.y],
				map[mod(this.x - 1, mapSize)][mod(this.y + 1, mapSize)],
				map[this.x][mod(this.y + 1, mapSize)],
			];
		}
		adjacentToLand(requirePlayerTile){
			for (let i = 0; i < this.neighbors.length; i++) {
				if (this.neighbors[i].type != 0) {
					if (requirePlayerTile && this.neighbors[i].owner == players[0]) {
						return true;
					} else if (!requirePlayerTile) {
						return true;
					}
				}
			}
		}
		hexesWithinDist(n, moveBiomes) {
			if (moveBiomes == undefined) moveBiomes = [1, 1, 1, 1];
			var canGo = [this],
			fringes = [[this]];
	    for (let i = 1; i <= n; i++) {
				fringes.push([]);
				for (let j = 0; j < fringes[i-1].length; j++) {
					for (let k = 0; k < fringes[i-1][j].neighbors.length; k++) {
						let neighbor = fringes[i-1][j].neighbors[k];
						if (canGo.indexOf(neighbor) == -1 && moveBiomes[neighbor.type]) {
							canGo.push(neighbor);
							fringes[i].push(neighbor);
						}
					}
				}
			}
	    return canGo;
		}
		draw(color, r){
			r = r || 16;
			let x = (this.x + this.y) * r * 1.5, y = (this.y - this.x) * r * .866,
			Hshift = mapSize * r * 1.5, Vshift = mapSize * r * .866, borders = [];
			if(this.owner) {
				for(let i = 0, n = this.neighbors; i < 6; i++){
					if(n[i].owner != this.owner) {
						borders.push(i);
					}
				}
			}
			if (enableStrategicMapView) {
				if (this.owner != null) {
					borders.push(this.owner.hexColor);
				} else if (this.type == 0) {
					borders.push("#000161")
				} else borders.push("#d7d7d7");
			} else if (this.owner) {
				borders.push(this.owner.hexColor);
			}
			if (selected.canMoveTo.indexOf(this) != -1 && color != "outline") {
				color = getColorFromScale(colors[this.type], "#000000", 0.25);
			}
			color = color || this.color;
			if (useInfiniteScroll) {
				this.renderWhere = [[0, 0], [-Hshift * 2, 0], [-Hshift, -Vshift], [-Hshift, Vshift]];
			} else this.renderWhere = [[0,0]];
			for (let i = 0; i < this.renderWhere.length; i++) {
				Hex.render(x + this.renderWhere[i][0], y + this.renderWhere[i][1], color, borders)
			}
		}
		drawUnits() {
			for (let i = 0; i < unitTypeNames.length; i++) {
				let num = this.unitNumberFromType(unitTypeNames[i]),
				isMissile = false;
				if (unitTypeNames[i] == "MRBM" || unitTypeNames[i] == "ICBM") isMissile = true;
				if (num !== 0) {
					let unitObject;
					for (let j = 0; j < this.units.length; j++) {
						if (this.units[j].typeName == unitTypeNames[i]) unitObject = this.units[j];
					}
					var coords = this.interiorPoint(unitObject.hexDisp[0], unitObject.hexDisp[1], 3), numSelected = 0;
					if (selected.tile.x == this.x && selected.tile.y == this.y) {
						numSelected = selected.unitsOfType(unitTypeNames[i]);
					}
					for (let j = 0; j < this.renderWhere.length; j++) {
						unitObject.render(coords[0] + this.renderWhere[j][0], coords[1] + this.renderWhere[j][1], num, numSelected, isMissile);
					}
				}
			}
		}
		drawBuildings() {
			var [x, y] = hexCoordToPoint(this.x, this.y),
			buildings = ["mines", "oilRigs", "uraniumMines", "uraniumRefineries"],
			bIcons = ["Mine", "OilRig", "UraniumMine", "UraniumRefinery"];
			if (this.cities > 0) {
				t.fillStyle = this.owner.hexColor;
				t.strokeStyle = "black";
				t.lineWidth = 1;
				t.beginPath();
				t.arc(x, y, r / 4.5, 0, Math.PI * 2);
				t.stroke();
				t.fill();
				t.fillStyle = "white";
				t.font = "6px sans-serif";
				t.textAlign = "center";
				t.fillText(this.cities, x, y + 2);
			}
			if (this.damage > 0) {
				var dp = this.interiorPoint(1, -2, 3);
				for (let j = 0; j < this.renderWhere.length; j++) {
					t.drawImage(spritesheet, 350, 0, 50, 50, dp[0] + this.renderWhere[j][0] - iconSize / 2,
						dp[1] + this.renderWhere[j][1] - iconSize / 2, iconSize, iconSize);
					this.addText(1, -2, this.damage);
				}
			}
			for (let i = 0; i < buildings.length; i++) {
				if (this[buildings[i]] > 0) {
					var dp = this.interiorPoint(this.hexDisp[buildings[i]][0], this.hexDisp[buildings[i]][1], 3);
					for (let j = 0; j < this.renderWhere.length; j++) {
						t.drawImage(spritesheet, 250, buildingTypeNames.indexOf(bIcons[i]) * 50,
							50, 50, dp[0] + this.renderWhere[j][0] - iconSize / 2,
							dp[1] + this.renderWhere[j][1] - iconSize / 2, iconSize, iconSize);
					}
					if (this[buildings[i]] > 1) {
						this.addText(this.hexDisp[buildings[i]][0], this.hexDisp[buildings[i]][1], this[buildings[i]]);
					}
				}
			}
		}
		drawResources() {
			var [x, y] = hexCoordToPoint(this.x, this.y),
			resources = ["steel", "oil", "uranium"];
			for (let i = 0; i < resources.length; i++) {
				if (this[resources[i]] > 0) {
					var dp = this.interiorPoint(this.hexDisp[resources[i]][0], this.hexDisp[resources[i]][1], 3);
					for (let j = 0; j < this.renderWhere.length; j++) {
						t.drawImage(spritesheet, 300, resourceTypeNames.indexOf(resources[i]) * 50,
						50, 50, dp[0] + this.renderWhere[j][0] - iconSize / 2,
						dp[1] + this.renderWhere[j][1] - iconSize / 2, iconSize, iconSize);
					}
					if (this[resources[i] + "Sources"] > 1) {
						this.addText(this.hexDisp[resources[i]][0], this.hexDisp[resources[i]][1], this[resources[i] + "Sources"]);
					}
				}
			}
		}
		addText(ix, iy, txt) {
			var point = this.interiorPoint(ix, iy, 3);
			t.fillStyle = "#fff";
			t.font = "2px sans-serif";
			t.textAlign = "center";
			for (let j = 0; j < this.renderWhere.length; j++) {
				t.fillText(txt, point[0] + this.renderWhere[j][0] + 2, point[1] + this.renderWhere[j][1]);
			}
		}
		static render(x, y, color, borders) {
			let pt = t.originalPoint(x, y), HP = r * t.getTransform().a, VP = HP * .866;
			if(pt.x + HP < 0 || pt.x - HP > width || pt.y + VP < 0 || pt.y - VP > height) return;
			t.beginPath();
			t.moveTo(x + r, y);
			t.lineTo(x + r / 2, y + r * .866);
			t.lineTo(x - r / 2, y + r * .866);
			t.lineTo(x - r, y);
			t.lineTo(x - r / 2, y - r * .866);
			t.lineTo(x + r / 2, y - r * .866);
			t.closePath();
			if (t.getTransform().a < 1 && enableStrategicMapView) {
				t.fillStyle = borders[borders.length - 1];
				t.fill();
			} else if(color == "outline") {
				t.lineWidth = 1;
				t.strokeStyle = "#ffffff";
				t.stroke();
				t.lineWidth = 1;
			} else {
				t.lineWidth = 1;
				t.fillStyle = color;
				t.fill();
			}
			let borderColor = borders.pop();
			if(!borderColor) return;
			for(let i = 0; i < borders.length; i++){
				let ang = borders[i];
				t.beginPath();
				t.moveTo(x + Math.cos(Math.PI / 3 * ang) * r * 0.95, y - Math.sin(Math.PI / 3 * ang) * r * 0.95);
				t.lineTo(x + Math.cos(Math.PI / 3 * (ang + 1)) * r * 0.95, y - Math.sin(Math.PI / 3 * (ang + 1)) * r * 0.95);
				t.strokeStyle = borderColor;
				t.stroke();
			}
		}
		static round(x, y){
			[x, y] = [(x - 1.732 * y) / r / 3, (x + 1.732 * y) / r / 3];
			let z = -x - y, _x = Math.round(x), _y = Math.round(y), _z = Math.round(z),
				dx = Math.abs(x - _x), dy = Math.abs(y - _y), dz = Math.abs(z - _z),
				dm = Math.max(dx, dy, dz);
			if (dm == dx) {
				return map[mod(-_y - _z, mapSize)][mod(_y, mapSize)];
			} else if (dm == dy) {
				return map[mod(_x, mapSize)][mod(-_x - _z, mapSize)];
			} else if (dm == dz) {
				return map[mod(_x, mapSize)][mod(_y, mapSize)];
			} else return {draw:function(){}}; // avoid errors lol
		}
		static round2(x, y) { //same as round but returns coordinates instead of returning map hex
			var rx = Math.round(x),
	    ry = Math.round(-x-y),
	    rz = Math.round(y),
			x_diff = Math.abs(rx - x),
			y_diff = Math.abs(ry + x + y),
			z_diff = Math.abs(rz - y);
	    if (x_diff > y_diff && x_diff > z_diff) {
				rx = -ry-rz
			} else if (y_diff > z_diff) {
	        ry = -rx-rz
	    } else {
				rz = -rx-ry
			}
			return [rx, rz];
		}
		distanceTo(hx, hy) {
			var dx = Math.min(Math.abs(hx - this.x), Math.abs(map.length - this.x - hx)),
			dy = Math.min(Math.abs(hy - this.y), Math.abs(map.length - this.y - hy));
			return dx + dy;
		}
		killUnbasedUnits() {
			for (let i = this.units.length - 1; i >= 0; i--) {
				if (!this.units[i].isBase[this.type]) this.units.splice(i, 1);
			}
			for (let i = 0; i < this.units.length; i++) {
				if (this.units[i].typeName == "AircraftCarrier") {
					let excessPlanes = this.units[i].carriedPlanes() - this.units[i].carryPlanes;
					while (excessPlanes > 0) {
						this.units[i].passengers.pop();
						--excessPlanes;
					}
				} else {
					let excessWeight = this.units[i].carriedWeight() - this.units[i].carryWeight;
					while (excessWeight > 0) {
						let killed = this.units[i].passengers.pop();
						excessWeight -= killed.weight;
					}
				}
			}
		}
		unitNumberFromType(typeName) {
			let sum = 0;
			for (let i = 0; i < this.units.length; i++) {
				if (this.units[i].typeName == typeName) ++sum;
			}
			return sum;
		}
		getAllUnitsOfType(typeName) {
			let r = [];
			for (let i = 0; i < this.units.length; i++) {
				if (this.units[i].typeName == typeName) r.push(this.units[i]);
			}
			return r;
		}
		extractResources() {
			var production = {
				development : this.cities,
				oil : this.oilRigs,
				steel : this.mines,
				uranium : this.uraniumMines
			}
			this.developmentSources = this.cities; //to avoid having to program exception for cities below
			for (let i in production) {
				let increment = Math.min(this[i + "Sources"], production[i])
				this[i] -= increment;
				production[i] = increment;
				if (this[i] < 0) {
					production[i] += this[i];
					this[i] = 0;
				}
			}
			return production;
		}
		addResource(type, quantity) {
			if (quantity == undefined) quantity = defaultResourceQuantity;
			this[type] += quantity;
			++this[type + "Sources"];
		}
		click(x, y, selectAll) {
			var [tx, ty] = hexCoordToPoint(this.x, this.y),
			n = 3;
			x -= tx;
			y -= ty;
			var hexCoords = Hex.round2((x * Math.sqrt(3)/3 - y/3) / (r/n/1.5), y * 2/3 / (r/n/1.5));
			for (let i = 0; i < this.units.length; i++) {
				if (this.units[i].hexDisp[0] == hexCoords[0] && this.units[i].hexDisp[1] == hexCoords[1]) {
					this.units[i].click(this.x, this.y, selectAll);
					return;
				}
			}
			selected.clear();
			if (selectAll) selected.selectAllFromTile(this);
			/*for (let i in this.hexDisp) {
				if (hexCoords[0] == this.hexDisp[i][0] && hexCoords[1] == this.hexDisp[i][1] && this[i] > 0) {
					//IN CASE BUILDINGS NEED TO DO SOMETHING ON CLICK, UNCOMMENT AND ADD SOMETHING HERE
				}
			}*/
		}
		interiorPoint(x, y, n) {
			let dx = Math.sqrt(3) * (x + y / 2) * r / n / 1.5, //no idea where the 1.5 comes from, but it works
    	dy = 3/2 * y * r / n / 1.5;
			return [dx + (this.x + this.y) * r * 1.5, dy + (this.y - this.x) * r * .866];
		}
		killUnitsWithProbability(prob, exempted) {
			if (exempted == undefined) exempted = [];
			for (let i = 0; i < this.units.length; i++) {
				if (Math.random() > prob || exempted.indexOf(this.units[i].typeName) != -1) {
					this.units[i].markedForDestruction = false;
				} else this.units[i].markedForDestruction = true;
			}
			this.units = removeMultipleFromArrayByProp(this.units, "markedForDestruction", true);
		}
		getRandomBuilding() {
			//used for deciding which building to kill once a tile reaches a certain amount of damage
			let arr = [];
			arr = arr.concat(new Array(this.mines).fill("mines"));
			arr = arr.concat(new Array(this.uraniumMines).fill("uraniumMines"));
			arr = arr.concat(new Array(this.oilRigs).fill("oilRigs"));
			arr = arr.concat(new Array(this.uraniumRefineries).fill("uraniumRefineries"));
			return arr[Math.floor(Math.random() * arr.length)]; //^is there a better way to do this?
		}
		nuke() { //this function is totally MAD
			this.cities = Math.floor(this.cities / 3);
			this.oil = 0;
			this.oilSources = 0;
			this.steel = 0;
			this.steelSources = 0;
			this.uranium = 0;
			this.uraniumSources = 0;
			this.mines = 0;
			this.uraniumMines = 0;
			this.oilRigs = 0;
			this.uraniumRefineries = 0;
			this.killUnitsWithProbability(0.4, launchedMissileTypeNames);
			for (let i = 0; i < this.neighbors.length; i++) {
				this.neighbors[i].cities = Math.floor(this.neighbors[i].cities / 1.5);
				this.neighbors[i].killUnitsWithProbability(0.2);
			}
			moved = true;
			this.type = 4;
			this.color = colors[this.type];
		}
		bomb(bombers) {
			this.damage += bombers;
		}
	}
	class Player {
		constructor(country){
			this.name = country;
			this.abbr = getAbbr(country);
			this.capital = { x: -1, y: -1 };
			this.development = 8;
			this.oil = 20;
			this.steel = 20;
			this.uranium = 0;
			this.enrichedUranium = 0;
			this.buildings = 0;
			this.landUnits = 0;
			this.seaUnits = 0;
			this.airUnits = 0;
			this.tileList = [];
			this.color = 'indigo'; // TEMPORARY, players should get color code from server.
			this.hexColor = '#3f51b5'; // used by Hex.draw, (borders/units/buildings etc.)
			this.reconstitutedCities = 0;
		}
		updateInfoBar() {
			for (let i = 0; i < resourceNames.length - 1; i++) {
				if (resourceNames[i] != "uranium") {
					document.getElementById("info-" + resourceNames[i]).innerHTML = "<i class='material-icons'>" + materialResourceIcons[resourceNames[i]] + "</i>" + this[resourceNames[i]];
				}
				if (resourceNames[i] == "development") {
					document.getElementById("info-" + resourceNames[i]).innerHTML += "/" + this.totalCities();
				}
			}
			document.getElementById("info-uranium").innerHTML = '<img src="images/radioactive.png" width="24" height="24"></i>' + players[0].enrichedUranium + "/" + players[0].uranium;
			if (this.reconstitutedCities > 0) {
				document.getElementById("reconstituted-cities").innerHTML = "RCs: " + this.reconstitutedCities;
			} else {
				document.getElementById("reconstituted-cities").innerHTML = "";
			}
		}
		totalCities() {
			let sum = 0;
			for (let i = 0; i < this.tileList.length; i++) {
				sum += this.tileList[i].cities;
			}
			return sum;
		}
		get numberOfUnits() {
			return this.landUnits + this.seaUnits + this.airUnits;
		}
		chat(text) {
			msg.innerHTML += `<div class="row valign-wrapper"><div class="col right-align">${HTMLescape(text)}</div><div class="col icon"><div class="circle ${this.color} white-text right">${this.abbr}</div></div></div>`;
			msg.scrollTop = msg.scrollHeight;
			// webSocket majikz
		}
		reconstituteCity(x, y) {
			--map[x][y].cities;
			++this.reconstitutedCities;
			this.updateInfoBar();
		}
		addUnit(x, y, unitType, build){
			if (build == undefined) build = true; //build = build || true;
			let hex = map[x][y],
			unit = new Unit(unitType, this);
			for (let i = 0; i < unit.cost.length; i++) {
				if (this[resourceNames[i]] < unit.cost[i]) {
					return false;
				}
			}
			if (!build) return true;
			for (let i = 0; i < unit.cost.length; i++) this[resourceNames[i]] -= unit.cost[i];
			this.updateInfoBar();
			unit.movesLeft = 0;
			map[x][y].units.push(unit);
			// more webSocket majikz and map majikz
		}
		addBuilding(x, y, building, build){
			if (build == undefined) build = true;//build = build || true;
			let hex = map[x][y], cost = [];
			switch (building) {
				case "Mine":
					cost = [4, 0, 4, 0];
					break;
				case "OilRig":
					cost = [4, 4, 0, 0];
					break;
				case "UraniumMine":
					cost = [8, 4, 4, 0];
					break;
				case "UraniumRefinery":
					cost = [20, 3, 10, 3];
					break;
				case "City":
					cost = [4 + hex.cities];
					break;
			}
			for (let i = 0; i < cost.length; i++) {
				if (this[resourceNames[i]] < cost[i]) {
					return false;
				}
			}
			if (!build) return true;
			for (let i = 0; i < cost.length; i++) this[resourceNames[i]] -= cost[i];
			switch (building) {
				case "Mine":
					++map[x][y].mines;
					break;
				case "OilRig":
					++map[x][y].oilRigs;
					break;
				case "UraniumMine":
					++map[x][y].uraniumMines;
					break;
				case "UraniumRefinery":
					++map[x][y].uraniumRefineries;
					break;
				case "City":
					++map[x][y].cities;
			}
			this.updateInfoBar();
			// even more webSocket majikz and map majikz
		}
		addResource(x, y, resourceType, build) {
			if (build == undefined) build = true;
			if (this.reconstitutedCities < 2) return false;
			if (!build) return true;
			this.reconstitutedCities -= 2;
			map[x][y].addResource(resourceType);
			this.updateInfoBar();
		}
		getTileResources() {
			for (let i = 0; i < this.tileList.length; i++) {
				let tileResources = this.tileList[i].extractResources();
				for (let j in tileResources) {
					this[j] += tileResources[j];
				}
				if (this.tileList[i].uraniumRefineries > 0 && this.uranium > 0) {
					--this.uranium;
					++this.enrichedUranium;
				}
			}
		}
		updateOwnedTiles() {
			for (let x = 0; x < map.length; x++) {
				for (let y = 0; y < map[x].length; y++) {
					if (map[x][y].owner == null && map[x][y].unitNumberFromType("Infantry") > 0) {
						if (map[x][y].units[0].owner.name == this.name) {
							map[x][y].owner = this;
							this.tileList.push(map[x][y]);
						}
					}
				}
			}
		}
		nextTurn() {
			this.development = 0;
			this.reconstitutedCities = 0;
			this.getTileResources();
			this.updateOwnedTiles();
			this.updateInfoBar();
		}
		canAfford(dev, oil, steel, uranium) {
			if (dev > this.development) return false;
			if (oil > this.oil) return false;
			if (steel > this.steel) return false;
			if (uranium > this.uranium) return false;
			return true;
		}
		unenrichUranium() {
			if (this.enrichedUranium > 0) {
				--this.enrichedUranium;
				++this.uranium;
				this.updateInfoBar();
			} else {
				alert("You have no enriched uranium that can be converted back into regular uranium.");
			}
		}
	}
	function getAbbr(str){
		let arr = str.split(' ').filter(e => e.toLowerCase() != 'of'), l = arr.length;
		if(l == 1) return arr[0].slice(0, 3).toUpperCase();
		if(l == 2) return (arr[0].slice(0, 2) + arr[1].slice(0, 1)).toUpperCase();
		return (arr[0].slice(0, 1) + arr[1].slice(0, 1) + arr[2].slice(0, 1)).toUpperCase();
	}
	function HTMLescape(str){
		return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt')
		.replace(/\*(.+)\*/g, '<b>$1</b>') // Skype formatting syntax
		.replace(/_(.+)_/g, '<i>$1</i>')
		.replace(/~(.+)~/g, '<s>$1</s>')
		.replace(/{code}(.+){code}/g, '<code>$1</code>');
	}
	class Unit {
		constructor(typeName, owner, color) {
			this.owner = owner;
			this.color = color || owner.hexColor;
			this.typeName = typeName;
			this.passengers = [];
			this.carryPlanes = 0; //defaults (most common);
			this.carryWeight = 0;
			this.isPlane = false;
			this.selected = false;
			switch (typeName) {
				case "Infantry":
					this.move = 2;
					this.cost = [2, 0, 0, 0, 0];
					this.weight = 1;
					this.canMove = [false, true, true, true, true]; //[0] -> sea, [1] -> land, [2] -> desert, etc.
					this.isBase = [false, true, true, true, false]; //can unit stop and stay there without dying
					this.hexDisp = [-1, -1]; //where in a tile the unit is displayed (see the intrahex position helper in the images folder)
					this.category = 1; //0->sea; 1->land; 2->air; 3->missile (used when drawing unit)
					break;
				case "MechanizedInfantry":
					this.move = 2;
					this.cost = [2, 1, 0, 0, 0];
					this.weight = 2;
					this.canMove = [false, true, true, true, true];
					this.isBase = [false, true, true, true, false];
					this.hexDisp = [2, -1];
					this.category = 1;
					break;
				case "Artillery":
					this.move = 2;
					this.cost = [3, 1, 0, 0, 0];
					this.weight = 2;
					this.canMove = [false, true, true, true, true];
					this.isBase = [false, true, true, true, false];
					this.hexDisp = [-2, 1]
					this.category = 1;
					break;
				case "Tank":
					this.move = 2;
					this.cost = [2, 1, 1, 0, 0];
					this.weight = 2;
					this.canMove = [false, true, true, true, true];
					this.isBase = [false, true, true, true, false];
					this.hexDisp = [1, 1]
					this.category = 1;
					break;
				case "Destroyer":
					this.move = 3;
					this.cost = [2, 0, 2, 0, 0];
					this.weight = 40; //some number larger than what anything can carry
					this.canMove = [true, false, false, false, false];
					this.isBase = [true, false, false, false, false];
					this.hexDisp = [0, -1];
					this.category = 0;
					break;
				case "Cruiser":
					this.move = 3;
					this.cost = [2, 2, 0, 0, 0];
					this.weight = 40;
					this.canMove = [true, false, false, false, false];
					this.isBase = [true, false, false, false, false];
					this.hexDisp = [1, 0];
					this.category = 0;
					break;
				case "Battleship":
					this.move = 3;
					this.cost = [2, 2, 2, 0, 0];
					this.weight = 40;
					this.canMove = [true, false, false, false, false];
					this.isBase = [true, false, false, false, false];
					this.hexDisp = [-1, 0];
					this.category = 0;
					break;
				case "AircraftCarrier":
					this.move = 3;
					this.cost = [3, 1, 3, 0, 0];
					this.weight = 80;
					this.carryWeight = 0;
					this.carryPlanes = 4;
					this.canMove = [true, false, false, false, false];
					this.isBase = [true, false, false, false, false];
					this.hexDisp = [0, 0];
					this.category = 0;
					break;
				case "Submarine":
					this.move = 3;
					this.cost = [2, 2, 0, 0, 0];
					this.weight = 40;
					this.canMove = [true, false, false, false, false];
					this.isBase = [true, false, false, false, false];
					this.hexDisp = [-1, 2];
					this.category = 0;
					break;
				case "Transport":
					this.move = 3;
					this.cost = [1, 4, 0, 0, 0];
					this.weight = 40;
					this.carryWeight = 12;
					this.canMove = [true, false, false, false, false];
					this.isBase = [true, false, false, false, false];
					this.hexDisp = [1, -1];
					this.category = 0;
					break;
				case "Fighter":
					this.move = 8;
					this.cost = [4, 0, 3, 0, 0];
					this.weight = 999;
					this.carryWeight = 1;
					this.canMove = [true, true, true, true, true];
					this.isBase = [false, true, true, true, false];
					this.isPlane = true;
					this.hexDisp = [0, -2];
					this.category = 2;
					break;
				case "Bomber":
					this.move = 8;
					this.cost = [4, 3, 0, 0, 0];
					this.weight = 999;
					this.carryWeight = 2;
					this.canMove = [true, true, true, true, true];
					this.isBase = [false, true, true, true, false];
					this.isPlane = true;
					this.hexDisp = [2, -2];
					this.category = 2;
					break;
				case "Helicopter":
					this.move = 3;
					this.cost = [3, 1, 1, 0, 0];
					this.weight = 2;
					this.canMove = [true, true, true, true, true];
					this.isBase = [false, true, true, false, false];
					this.hexDisp = [1, -2];
					this.category = 2;
					break;
				case "MRBM":
					this.move = 1;
					this.cost = [8, 1, 1, 0, 4];
					this.weight = 12;
					this.canMove = [false, true, true, true, true];
					this.isBase = [false, true, true, true, false];
					this.hexDisp = [-2, 0];
					this.category = 3;
					break;
				case "MRBMlaunched":
					this.timeUntilDetonation = 0;
					this.move = 6;
					this.cost = [0, 0, 0, 0, 0];
					this.weight = 999;
					this.canMove = [true, true, true, true, true];
					this.isBase = [false, false, false, false, false];
					this.hexDisp = [-2, 0];
					this.category = 4;
					break;
				case "ICBM":
					this.move = 1;
					this.cost = [10, 1, 4, 0, 4];
					this.weight = 12;
					this.canMove = [false, true, true, true, true];
					this.isBase = [false, true, true, true, false];
					this.hexDisp = [2, 0];
					this.category = 3;
					break;
				case "ICBMlaunched":
					this.timeUntilDetonation = 1;
					this.move = 6;
					this.cost = [0, 0, 0, 0, 0];
					this.weight = 999;
					this.canMove = [true, true, true, true, true];
					this.isBase = [true, true, true, true, true];
					this.hexDisp = [2, 0];
					this.category = 4;
					break;
			}
			this.movesLeft = this.move;
		}
		icon() {
			return document.getElementById(iconSet + this.typeName);
		}
		canCarry(unit) {
			if (unit.isPlane) {
				if (this.carriedPlanes() + 1 > this.carryPlanes) return false;
				return true;
			} else {
				if (this.carriedWeight() + unit.weight > this.carryWeight) return false;
				return true;
			}
		}
		carriedWeight() { //does not count airplanes
			let sum = 0;
			for (let i = 0; i < this.passengers.length; i++) {
				if (!this.passengers[i].isPlane) sum += this.passengers[i].weight;
			}
			return sum;
		}
		carriedPlanes() {
			let sum = 0;
			for (let i = 0; i < this.passengers.length; i++) {
				if (this.passengers[i].isPlane) ++sum;
			}
			return sum;
		}
		click(hexx, hexy, selectAll) {
			selected.selectUnit(this, hexx, hexy, selectAll);
		}
		render(x, y, number, numSelected, isMissile) { //DRAW UNITS
			let size = iconSize;
			t.fillStyle = this.color;
			if (this.canMove[0] && iconSet == "icon" && !isMissile) {
				t.lineWidth = 0.5;
				t.strokeStyle = "transparent";
				if (numSelected > 0) t.strokeStyle = this.color;
				t.beginPath();
				t.arc(x, y, size / 2, 0, Math.PI * 2);
				t.stroke();
				t.fill();
			} else if (!isMissile) {
				if (numSelected > 0) {
					t.fillRect(x - size / 2 - 0.5, y - size / 2 - 0.5, size + 1, size + 1);
				}
				t.fillRect(x - size / 2, y - size / 2, size, size);
			}
			t.drawImage(spritesheet, this.category * 50, typeCategories[this.category].indexOf(this.typeName) * 50,
				50, 50, x - size / 2, y - size / 2, size, size);
			t.fillStyle = "#fff";
			t.font = "3px sans-serif";
			t.textAlign = "center";
			var text = number;
			if (numSelected > 0) text = numSelected + "/" + number;
			t.fillText(text, x + size / 6, y - size / 6);
		}
	}
	for(let x = 0; x < mapSize; x++){
		map[x] = new Array(mapSize);
		for(let y = 0; y < mapSize; y++)
			new Hex(x, y, 0);
	}
	function changeColor(color){ // ideally this only runs once...
		let colorScheme = MDcolors[color];
		$('.indigo').removeClass('indigo').addClass(colorScheme[0]);
		$('.indigo-text').removeClass('indigo-text').addClass(colorScheme[0] + '-text');
		$('.pink').removeClass('pink').addClass(colorScheme[1]);
		$('.pink-text').removeClass('pink-text').addClass(colorScheme[1] + '-text');
		if(color > 4) $('.white-text').removeClass('white-text').addClass('black-text');
	}
	function resetCtxMenu() {
		ctxmenu.style.display = "none";
		removeAllChildNodes(airUnitBuildMenu);
		removeAllChildNodes(buildingBuildMenu);
		removeAllChildNodes(unitBuildMenu);
		removeAllChildNodes(resourceBuildMenu);
		removeAllChildNodes(missileBuildMenu);
	}
	function mod(a, b){ return a - Math.floor(a / b) * b; }
	c.addEventListener('mousedown',function(evt){
		moved = true;
		mouse.x = evt.offsetX || (evt.pageX - c.offsetLeft);
		mouse.y = evt.offsetY || (evt.pageY - c.offsetTop);
		mouse.dragStart = t.transformedPoint(mouse.x, mouse.y);
		mouse.dragged = false;
	},false);
	c.addEventListener('mousemove',function(evt){
		moved = true;
		mouse.x = evt.offsetX || (evt.pageX - c.offsetLeft);
		mouse.y = evt.offsetY || (evt.pageY - c.offsetTop);
		mouse.dragged = true;
		if (mouse.dragStart) {
			var pt = t.transformedPoint(mouse.x, mouse.y);
			t.translate(pt.x - mouse.dragStart.x, pt.y - mouse.dragStart.y);
		}
	},false);
	c.addEventListener('mouseup',function(evt){
		moved = true;
		mouse.dragStart = null;
	},false);
	c.addEventListener('click',function(evt){ //MAIN MAP CANVAS CLICK EVENT
		resetCtxMenu();
		$('#menuCityBtn').off();
		$('#menuMineBtn').off();
		$('#menuOilRigBtn').off(); //disable event listeners on context menu
		if(mouse.dragged) return;
		if (Player.god == true){
			let pt = t.transformedPoint(mouse.x,mouse.y);
			Hex.round(pt.x, pt.y).owner = players[0];
			/*
			hex.type++;
			if(hex.type > 3) hex.type = 0;
			hex.color = colors[hex.type];
			*/
			moved = true;
		} else {
			var pt = t.transformedPoint(mouse.x, mouse.y),
			selectAll = false, hex = Hex.round(pt.x, pt.y);
			if (selected.canMoveTo.indexOf(hex) == -1 || selected.tile == hex) {
				if (keys[16] > 0) selectAll = true;
				hex.click(pt.x, pt.y, selectAll);
				selected.refreshMoves();
			} else {
				selected.moveTo(hex);
			}
		}
	},false);
	function ctxmenuAddIcons(typeNames, container, type, hex, category, x, y) {
		for (let i = 0; i < typeNames.length; i++) {
			var div = document.createElement("div"),
			cnv = document.createElement("canvas");
			cnv.width = "50";
			cnv.height = "50";
			div.className = "row";
			cnv.getContext("2d").drawImage(spritesheet, category * 50, typeCategories[category].indexOf(typeNames[i]) * 50, 50, 50, 0, 0, 50, 50);
			container.appendChild(div);
			div.appendChild(cnv);
			if (type === "building") {
				cnv.addEventListener("click", function() {
					players[0].addBuilding(hex.x, hex.y, typeNames[i]);
					resetCtxMenu();
					createCtxMenu(x, y, hex);
					moved = true;
				});
			} else if (type === "unit") {
				cnv.addEventListener("click", function() {
					players[0].addUnit(hex.x, hex.y, typeNames[i]);
					resetCtxMenu();
					createCtxMenu(x, y, hex);
					moved = true;
				});
			} else if (type === "resource") {
				cnv.addEventListener("click", function() {
					players[0].addResource(hex.x, hex.y, typeNames[i]);
					resetCtxMenu();
					createCtxMenu(x, y, hex);
					moved = true;
				});
			}
		}
	}
	function getAffordableItems(arr, x, y, type) {
		let r = [];
		for (let i = 0; i < arr.length; i++) {
			if (type == "building") {
				if (players[0].addBuilding(x, y, arr[i], false)) r.push(arr[i]);
			} else if (type == "unit") {
				if (players[0].addUnit(x, y, arr[i], false)) r.push(arr[i]);
			} else if (type == "resource") {
				if (players[0].addResource(x, y, arr[i], false)) r.push(arr[i]);
			}
		}
		return r;
	}
	function createCtxMenu(x, y, hex) {
		ctxmenu.style.display = "inline";
		ctxmenu.style.left = x;
		ctxmenu.style.top = y;
		ctxmenutitle.innerHTML = "Sector " + "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[hex.y] + (hex.x + 1);
		economymenu.style.display = "inline";
		if (hex.owner != null && hex.type > 0) {
			if (players[0].addBuilding(hex.x, hex.y, "City", false)) {
				var div = document.createElement("div"),
				img = document.createElement("img");
				div.className = "row";
				img.src = "images/addCityIcon.png";
				buildingBuildMenu.appendChild(div);
				div.appendChild(img);
				img.addEventListener("click", function() {
					players[0].addBuilding(hex.x, hex.y, "City");
					resetCtxMenu();
					createCtxMenu(x, y, hex);
					moved = true;
				});
			}
			if (hex.cities > 0) { //copy-paste code incoming!
				var div = document.createElement("div"),
				img = document.createElement("img");
				div.className = "row";
				img.src = "images/removeCityIcon.png";
				buildingBuildMenu.appendChild(div);
				div.appendChild(img);
				img.addEventListener("click", function() {
					players[0].reconstituteCity(hex.x, hex.y);
					resetCtxMenu();
					createCtxMenu(x, y, hex);
					moved = true;
				});
			}
			ctxmenuAddIcons(getAffordableItems(buildingTypeNames, hex.x, hex.y, "building"), buildingBuildMenu, "building", hex, 5, x, y);
			ctxmenuAddIcons(getAffordableItems(airUnitTypeNames, hex.x, hex.y, "unit"), airUnitBuildMenu, "unit", hex, 2, x, y);
			ctxmenuAddIcons(getAffordableItems(landUnitTypeNames, hex.x, hex.y, "unit"), unitBuildMenu, "unit", hex, 1, x, y);
			ctxmenuAddIcons(getAffordableItems(missileTypeNames, hex.x, hex.y, "unit"), missileBuildMenu, "unit", hex, 3, x, y);
			let resources = [];
			if (hex.steel == 0) {
				for (let i = 0; i < hex.neighbors.length; i++) {
					if (resources.indexOf("steel") == -1 && hex.neighbors[i].steel > 0) resources.push("steel");
				}
			}
			if (hex.oil > 0) resources.push("oil");
			ctxmenuAddIcons(getAffordableItems(resources, hex.x, hex.y, "resource"), resourceBuildMenu, "resource", hex, 6, x, y);
		}
		if (hex.type == 0 && hex.adjacentToLand(true)) {
			ctxmenuAddIcons(getAffordableItems(seaUnitTypeNames, hex.x, hex.y, "unit"), unitBuildMenu, "unit", hex, 0, x, y);
		}
	}
	c.addEventListener('contextmenu',function(evt){
		evt.preventDefault();
		resetCtxMenu();
		var pt = t.transformedPoint(mouse.x, mouse.y),
		hex = Hex.round(pt.x, pt.y),
		x = evt.pageX + "px",
		y = evt.pageY + "px";
		createCtxMenu(x, y, hex);
		return false;
	},false);
	chatInput.addEventListener('keydown',function(evt){
		let text = this.value;
		if(evt.keyCode == 13){
			if(evt.shiftKey && text.length == 0) // to clear chat, press shift + enter
				msg.innerHTML = '';
			else if (text.trim().length > 0) {
				text = text.trim().replace(/\s{2,}/g, ' ');
				if(text[0] == '>') {
					// news
				} else if (text[0] == '@') {
					// private message
				} else if (text[0] == '!') {
					// exclusive message
				} else if (text[0] == '~') {
					// draw request
				} else if (text == '/ai on') {
					alert("HAL-9000 has been activated. Plotting course for Jupiter ...")
				} else if (text == '/ai off') {
					alert("I'm sorry, Dave. I'm afraid I can't do that.")
				} else if (text == '/debug') {
					alert("Analyzing ... ");
					alert("Analysis complete. All hope is lost. Shut down system and wait for singularity.");
				}
				players[0].chat(text);
			}
			chatInput.value = '';
		}
	})
	document.addEventListener('keydown',function(evt){
		if($(':focus').length) return;
		switch(evt.keyCode){
			case 49: mapButton.click(); break;
			case 50: historyButton.click(); break;
			case 51: statsButton.click(); break;
		}
		keys[evt.keyCode] = 1 - evt.shiftKey * .866; // shift for slower movement
	});
	document.addEventListener('keyup',function(evt){
		keys[evt.keyCode] = 0;
	});
	window.addEventListener('resize',function(evt){
		c.width = width = window.innerWidth;
		c.height = height = window.innerHeight - 64;
		trackTransforms(t);
		mouse.x = width / 2;
		mouse.y = width / 2;
		moved = true;
	});
	function zoom(clicks){
		moved = true;
		let pt = t.transformedPoint(mouse.x,mouse.y), factor = Math.pow(scaleFactor,clicks*zoomDirection);
		t.save();
		t.translate(pt.x,pt.y);
		t.scale(factor,factor);
		t.translate(-pt.x,-pt.y);
		let a = t.getTransform().a;
		if(a < 0.866 || a > 8) t.restore();
	}
	addWheelListener(c,function(evt){
		zoom(Math.min(Math.max(evt.deltaY / 100, -8), 8));
		return evt.preventDefault() && false;
	});
	let interval = 20, now, then = Date.now(), delta; // FPS controller and input check for optimizations
	function draw(){
		timer = requestAnimationFrame(draw);
		now = Date.now();
		delta = now - then;
		if(delta <= interval) return;
		if(keys[68] - keys[65] || keys[83] - keys[87] || keys[38] - keys[40]) {
			moved = true;
			t.translate((keys[65] - keys[68]) * 5 / t.getTransform().a, (keys[87] - keys[83]) * 5 / t.getTransform().a);
			zoom(keys[38] - keys[40]);
		}
		if(!moved) return;
		moved = false;
		then = now - (delta % interval);
		t.save();
		t.setTransform(1,0,0,1,0,0);
		t.clearRect(0, 0, width, height);
		t.restore();
		for(let x = 0; x < mapSize; x++){
			for(let y = 0; y < mapSize; y++)
				map[x][y].draw();
		}
		let pt = t.transformedPoint(mouse.x, mouse.y);
		Hex.round(pt.x, pt.y).draw("outline");
		pt = t.transformedPoint(width / 2, height / 2);
		c.style.backgroundPosition = (width / 2 - pt.x) / 20 + 'px ' + (height / 2 - pt.y) / 20 + 'px';
		for(let x = 0; x < mapSize; x++){ //looping second time so that hexes don't cover units
			for(let y = 0; y < mapSize; y++) {
				map[x][y].drawUnits();
				map[x][y].drawBuildings();
				map[x][y].drawResources();
			}
		}
	}
	var prng = {
		//see https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
		m : Math.pow(2, 32),
		a : 1664525,
		c : 1013904223,
		seed : 12,
		next : function() {
			this.seed = (this.a * this.seed + this.c) % this.m;
			return this.seed;
		},
		nextIn : function(n) { //returns value in range 0 < value < n
			return this.next() / this.m * n;
		}
	}
	function generateResource(resourceName, number, allowedTerrainTypes) {
		for (let i = 0; i < number; i++) {
			let x = Math.floor(prng.nextIn(map.length)),
			y = Math.floor(prng.nextIn(map.length));
			if (allowedTerrainTypes[map[x][y].type] == 1 && map[x][y][resourceName] == 0) {
				map[x][y][resourceName] = defaultResourceQuantity;
				++map[x][y][resourceName + "Sources"];
			}
		}
	}
	function seedToMap(s) {
		prng.seed = s;
		var borderLand = 0.4,
		borderDesert = 0.6,
		borderMountain = 0.7,
		levelSizes = [26, 12, 6, 3], //size of (square) level tiles
		levelNumbers = [1000, 1000, 1000, 1000], //number of tiles for each level that will need to be generated to fill map (optimize later)
		levels = [], //values for each level
		levelMultipliers = [0.1, 0.2, 0.3, 0.2, 0.2]; //weights assigned to sum of each level (should add to 1)
		for (let i = 0; i < levelSizes.length; i++)
			//levelNumbers.push(Math.ceil(Math.pow(24, 2) / Math.pow(levelSizes[i], 2)));
			levels.push(new Array(levelNumbers[i]));
		for (let i = 0; i < levels.length; i++) {
			for (let j = 0; j < levels[i].length; j++)
				levels[i][j] = prng.next();
		}
		for (let x = 0; x < map.length; x++) {
			for (let y = 0; y < map[x].length; y++) {
				var sum = 0;
				for (let a = 0; a < levelMultipliers.length - 1; a++)
					sum += (levels[a][Math.floor(x / levelSizes[a]) * levelSizes[a] + Math.floor(y / levelSizes[a])]) * levelMultipliers[a];
				sum += prng.next() * levelMultipliers[levelMultipliers.length - 1];
				if (sum / prng.m > borderMountain) {
					map[x][y].type = 3;
				} else if (sum / prng.m > borderDesert) {
					map[x][y].type = 2;
				} else if (sum / prng.m > borderLand) {
					map[x][y].type = 1;
				} else {
					map[x][y].type = 0; //redundant, but allows for easier console testing since ocean can overwrite land
				}
				map[x][y].sum = sum / prng.m; //debug only - comment out if desired
				map[x][y].color = colors[map[x][y].type];
				moved = true;
			}
		}
		generateResource("oil", 16, [1, 1, 1, 1]);
		generateResource("steel", 250, [0, 0, 1, 1]);
		generateResource("uranium", 7, [0, 1, 1, 1]);
	}
	function clearResources() {
		for (let x = 0; x < map.length; x++) {
			for (let y = 0; y < map.length; y++) {
				map[x][y].oil = 0;
				map[x][y].steel = 0;
				map[x][y].uranium = 0;
			}
		}
	}
	//seedToMap(Math.random() * 1000) //start with random map
	function addLeadingZeros(n, len) {
	    var s = n+"";
	    while (s.length < len) s = "0" + s;
	    return s;
	}
	function compressCoordinateAndValue(x, y, val) {
		if (val > 998 && val != Infinity) return;
		if (val == Infinity) val = "999";
		y = addLeadingZeros(y, 2);
		val = addLeadingZeros(val, 3);
		return (parseInt(x + "" + y + "" + val)).toString(36);
	}
	function exportMap(){ // this allows maps up to 26x26 due to the doubles' 2^53 mantissa limit
		let arr = new Array(mapSize).fill(0);
		for(let x = 0; x < mapSize; x++){
			for(let y = 0; y < mapSize; y++)
				arr[x] += map[x][y].type * Math.pow(2, 2*y);
			arr[x] = arr[x].toString(36); // compress via base36
		}
		let p1 = arr.join(),
		oilSources = [], steelSources = [], uraniumSources = [];
		for (let x = 0; x < mapSize; x++) {
			for (let y = 0; y < mapSize; y++) {
				if (map[x][y].oil != 0) oilSources.push(compressCoordinateAndValue(x, y, map[x][y].oil));
				if (map[x][y].steel != 0) steelSources.push(compressCoordinateAndValue(x, y, map[x][y].steel));
				if (map[x][y].uranium != 0) uraniumSources.push(compressCoordinateAndValue(x, y, map[x][y].uranium));
			}
		}
		prompt("Your map: (" + mapSize + " x " + mapSize + ")", p1 + "|" + oilSources.join(",") + "|" + steelSources.join(",") + "|" + uraniumSources.join(","));
	}
	function importMap(str,size){
		if(size) mapSize = size;
		let r = (str || prompt("Enter a map string:")).split("|"),
		arr = r[0].split(","), oilSources = r[1].split(","),
		steelSources = r[2].split(","), uraniumSources = r[3].split(",");
		for(let x = 0; x < mapSize; x++){
			arr[x] = parseInt(arr[x] || 0, 36);
			for(let y = 0; y < mapSize; y++)
				map[x][y].color = colors[map[x][y].type = (arr[x] || 0) / Math.pow(2, 2*y) & 3];
				//hack: & 3 both floors the result (bitwise operator) and modulo the result by 4
		}
		unpackResourceString(steelSources, "steel");
		unpackResourceString(oilSources, "oil");
		unpackResourceString(uraniumSources, "uranium");
		moved = true;
	}
	function unpackResourceString(r, name) {
		for (let i = 0; i < r.length; i++) {
			let num = addLeadingZeros(parseInt(r[i], 36), 7),
			x = parseInt(num.substr(0,2)), y = parseInt(num.substr(2,2)), val = parseInt(num.substr(4,3));
			map[x][y][name] = val;
			++map[x][y][name + "Sources"];
		}
	}
	importMap("vkisfod,ewpm2oal,if376btp,ewofggbd,begwwf9x,1hd780k,ieydxy4w,3q64aakw,ihf6a9es,lxcvjbr4,4dulwetd,282dc,in0fdzkl,noi2nuop,imw4jxgl,ipbr4fv9,4ecbzur5,ikvkwfa7,15ft74cpp,zdbmp3qh,12ga122vp|asv,dvz,288v,290n,d4zr,f2fr,hguv,lpmv,lvt3,nmb3,10nfz,14t4v,14zb3|1jj,27h3,2cvj,4bv3,4i1b,6h0v,6ikf,8t4n,8vfz,902n,d1wn,jpvj,lo3b,nt93,rwmn,s9qv,u2k7,yhif,10h9r,10mo7,10nfz,10suf,12mfj,130bj,1313b,14rlb,14sd3,155hb,15693,1793j,17an3,17bev|6nyv,rxef,14sd3", 21);

	//importMap("vkisfod,ewoi4arh,2saawou9nh,3h4rgajdll,3h198khnit,1ha2ul0,ieydxy4w,3q64aakw,ihf6a9es,2sdt1xdrgg,2rw9o3kcn5,1k4k5dr7k,in0fdzi8,nodmuckc,2rwhlpdtlx,23cm6vde8l,4ecbzur5,8b71tlcv3,7dxjsh3kt,2vvi0f1ezt,2uegka0kyd,3haarsuy4g,50v5zzxeps,3uqyoqbjcw,2zkhzr5es0", mapSize);
	/* // map stats:
	sea tiles: 327 (52.32%)  |  plains tiles: 233 (37.28%)  |  desert tiles: 32 (5.12%)  |  mountain tiles: 33 (5.28%) */
	// importMap("annext,is0the0,best0game,ever0made,everyone0,should0,play0it0,because0,you0get0,to0rule0,the0whole,world0000",12);
	Player.god = false; // edit map with this

	function loadRenderTests() { //called above
		map[0][1].units = [new Unit("Infantry", players[0]),
			new Unit("Tank", players[0]),
			new Unit("Artillery", players[0]),
			new Unit("MechanizedInfantry", players[0]),
			new Unit("Artillery", players[0]),
			new Unit("MechanizedInfantry", players[0]),
		 	new Unit("Fighter", players[0]),
			new Unit("Bomber", players[0])];
		map[5][0].units = [new Unit("AircraftCarrier", players[0]),
			new Unit("Destroyer", players[0]),
			new Unit("Destroyer", players[0]),
			new Unit("Cruiser", players[0]),
			new Unit("Cruiser", players[0]),
			new Unit("Cruiser", players[0]),
			new Unit("Submarine", players[0]),
			new Unit("Transport", players[0]),
			new Unit("Battleship", players[0]),
			new Unit("Fighter", players[0]),
			new Unit("Bomber", players[0])];
		map[1][1].units = [new Unit("MRBM", players[0]), new Unit("ICBM", players[0])];
		map[0][0].unt
		map[0][1].cities = 8;
		map[0][1].mines = 1;
		map[0][1].oilRigs = 0;
		map[0][1].owner = players[0];
		players[0].tileList = [map[0][1]];
		players[0].updateInfoBar();
	}
	</script>
</body>
</html>
